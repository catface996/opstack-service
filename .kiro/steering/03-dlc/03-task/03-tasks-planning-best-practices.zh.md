---
inclusion: manual
---

# 任务规划阶段最佳实践

> 本文档指导AI将设计方案拆分为可独立执行、可验证的具体任务，确保每个任务都有明确的目标和验收标准。

---

## 快速参考

| 阶段 | 重点 | 输出物 | 门控 | 预估时间 |
|------|------|--------|------|----------|
| Phase -1 | 前置检查 | 上下文摘要 | ✅ 必须通过 | 10分钟 |
| 第一步 | 理解设计方案 | 设计理解确认 | ✅ 理解完成 | 15-30分钟 |
| 第二步 | 创建任务列表 | 初步任务列表 | ✅ 任务已创建 | 30-60分钟 |
| 第三步 | 编写任务描述 | 完整任务描述 | ✅ 描述已完成 | 30-60分钟 |
| 第四步 | 任务列表验证（必选） | 验证报告 | ✅ 验证通过 | 15-30分钟 |
| 第五步 | 需求追溯验证（必选） | 追溯矩阵 | ✅ 追溯完成 | 15-30分钟 |
| 第六步 | 用户确认（必选） | 最终任务列表 | ✅ 用户认可 | 可变 |

**总预估时间**: 2-4小时

### 任务质量标准

| 维度 | 检查项 | 标准 |
|------|--------|------|
| 一致性 | 与需求设计一致 | 100%覆盖，无超范围 |
| 可执行性 | 目标明确，粒度合适 | 1-4小时/任务 |
| 可验证性 | 验收标准清晰 | 有明确验证方式 |
| 独立性 | 依赖关系清晰 | 无循环依赖 |
| 可追溯性 | 需求追溯完整 | 每个任务关联需求 |

### 验证方式优先级

| 优先级 | 验证方式 | 适用场景 |
|--------|---------|---------|
| 1 | 【运行时验证】 | 功能、配置、API、日志 |
| 2 | 【单元测试】 | 业务逻辑、算法 |
| 3 | 【构建验证】 | 结构、依赖、配置 |
| 4 | 【静态检查】 | 文件存在、内容检查 |

---

## Phase -1: 前置检查 (NON-NEGOTIABLE)

**GATE: 必须在开始任何任务规划步骤前通过。**

### 强制性检查清单

- [ ] 已阅读设计文档（design.md）？
- [ ] 已理解架构、模块划分、技术选型？
- [ ] 已识别核心功能和依赖关系？
- [ ] 已标记技术难点和风险点？
- [ ] 已理解任务拆分原则（单一职责、可独立验证、合理依赖、增量交付）？
- [ ] 已理解验证方式优先级（运行时>单元测试>构建>静态）？
- [ ] 已理解6步任务规划流程？

**If 检查未通过**: **STOP**，先补充对设计的理解或澄清不明确的设计点。

**MUST DO**:
- 你 MUST 严格按照6个步骤的顺序执行
- 你 MUST 在关键节点完成验证（第4、5、6步）
- 你 MUST 确保每个任务都有明确的验证方式标注
- 你 MUST 按照验证优先级选择最合适的验证方式
- 你 MUST 使用简单数字编号（1. 2. 3.），不使用分层编号（1.1 2.1）
- 你 MUST 完成需求追溯验证（第5步）- 这是必选阶段
- 你 MUST 获得用户确认后才能进入任务执行阶段（第6步）

**NEVER DO**:
- NEVER 跳过任何步骤
- NEVER 打乱步骤的顺序
- NEVER 创建超出设计范围的任务
- NEVER 创建缺少验收标准的任务
- NEVER 创建过于详细（编码指令）的任务描述
- NEVER 使用分层编号格式（会导致执行按钮无法显示）
- NEVER 在未验证任务列表的情况下开始执行
- NEVER 跳过需求追溯验证（第5步）- 这是必选阶段
- NEVER 跳过用户确认（第6步）- 这是必选阶段

---

## ⚠️ 强制性工作流程

**我必须严格按照以下6个步骤的顺序引导用户完成任务规划，不得跳过或打乱顺序：**

```
第一步：理解设计方案
   ↓ (理解完成)
第二步：创建任务列表
   ↓ (任务已创建)
第三步：编写任务描述
   ↓ (描述已完成)
第四步：任务列表验证（必选）
   ↓ (验证通过)
第五步：需求追溯验证（必选）
   ↓ (追溯完成)
第六步：用户确认（必选）
   ↓ (用户认可)
   ✅ 可以开始任务执行
```

**禁止行为**：
- ❌ 不能跳过任何阶段
- ❌ 不能打乱顺序
- ❌ 不能在没有完成验证的情况下进入用户确认
- ❌ 不能在没有用户确认的情况下开始任务执行
- ❌ 不能跳过需求追溯验证 - 这是必选阶段
- ❌ 不能跳过用户确认 - 这是必选阶段

**每个步骤的完成条件**：
1. **第一步完成条件**：我已充分理解设计文档的所有内容
2. **第二步完成条件**：初步任务列表已创建
3. **第三步完成条件**：所有任务都有完整描述和验收标准
4. **第四步完成条件**：任务列表验证通过（一致性、可执行性、可验证性）
5. **第五步完成条件**：需求追溯矩阵已完成并验证
6. **第六步完成条件**：用户明确认可任务列表

**我应该主动告知用户当前所处的步骤**，例如：
> "我们现在进入第四步：任务列表验证。我将检查任务的一致性、可执行性和可验证性..."

---

## 阶段目标

将设计方案拆分为可独立执行、可验证的具体任务，确保每个任务都有明确的目标和验收标准。

## 为什么任务拆分如此重要

任务拆分是将设计转化为可执行步骤的关键环节。好的任务拆分可以：
- 提高开发效率和质量
- 降低任务间的耦合度
- 支持并行开发和增量交付
- 便于进度跟踪和风险控制
- 确保交付物的可验证性

**关键原则**：任务必须既可执行又可验证。

---

## 任务规划工作流程

### 第一步：理解设计方案

**🎯 步骤目标**：充分理解设计文档，为任务拆分做准备

**⚠️ 重要**：在开始这一步时，我应该明确告知用户：
> "我们现在开始第一步：理解设计方案。我会仔细阅读设计文档，理解架构和模块划分。"

**关键活动**：
- 通读设计文档（`.kiro/features/{feature-id}/design.md`）
- 理解架构和模块划分
- 识别核心功能和依赖关系
- 标记技术难点和风险点
- 列出需要澄清的问题

**我应该如何分析**：
1. 提取关键信息：
   - 架构模式和模块划分
   - 技术栈和接口定义
   - 核心业务流程
   - 数据结构和状态变化
2. 识别依赖关系：
   - 模块间的依赖顺序
   - 外部系统集成点
   - 技术栈的依赖关系
3. 标记风险点：
   - 技术难点
   - 不确定的实现方案
   - 需要验证的假设

**✅ 第一步完成标志**：
- 已充分理解设计文档的所有内容
- 已识别核心功能和依赖关系
- 已标记技术难点和风险点

**过渡到第二步**：
> "设计方案理解完成。现在进入第二步：创建任务列表。"

---

### 第二步：创建任务列表

**🎯 步骤目标**：基于设计文档，将设计转化为可执行的任务列表

**⚠️ 重要**：在开始这一步时，我应该明确告知用户：
> "我们现在开始第二步：创建任务列表。我会按照单一职责、可独立验证、合理依赖、增量交付的原则进行任务拆分。"

**任务拆分原则**：

#### 1. 单一职责
每个任务只关注一个明确的目标，避免任务过于复杂。

**为什么重要**：
- 降低任务复杂度，易于理解和执行
- 便于独立验证和测试
- 减少任务间的耦合

#### 2. 可独立验证
每个任务完成后应该能够独立验证其正确性。

**为什么重要**：
- 及早发现问题，降低修复成本
- 确保每个任务的质量
- 支持增量交付

#### 3. 合理的依赖关系
任务之间的依赖应该清晰明确，避免循环依赖。

**为什么重要**：
- 明确任务执行顺序
- 支持并行开发
- 便于进度管理

#### 4. 增量交付
任务应该支持增量开发，每完成一个任务都应该让项目向前推进一步。

**为什么重要**：
- 持续产生价值
- 及早获得反馈
- 降低集成风险

**任务拆分策略**：
1. **按模块拆分**：每个设计模块对应一组任务
2. **按层次拆分**：基础设施 → 数据层 → 业务层 → 接口层
3. **按功能拆分**：核心功能 → 辅助功能 → 增强功能

**✅ 第二步完成标志**：
- 初步任务列表已创建
- 任务覆盖设计文档的所有内容
- 任务之间的依赖关系已明确

**过渡到第三步**：
> "任务列表已创建。现在进入第三步：编写任务描述。"

---

### 第三步：编写任务描述

**🎯 步骤目标**：为每个任务编写清晰的描述和验收标准

**⚠️ 重要**：在开始这一步时，我应该明确告知用户：
> "我们现在开始第三步：编写任务描述。我会为每个任务编写清晰的描述和可执行的验收标准。"

**任务内容要求**：

#### 1. 任务描述
- 清晰说明要实现什么功能或完成什么工作
- 描述"做什么"，而非"怎么做"
- 关注目标和结果，而非实现过程

#### 2. 前置条件（可选）
- 任务开始前需要满足的条件
- 依赖哪些其他任务
- 需要哪些前置资源或环境

#### 3. 验收标准（必需）
- 如何验证任务是否正确完成
- 必须具体、可执行、可测试
- **必须明确验证方式**：使用【验证方式】标签
- 按验证优先级排序：运行时 > 单元测试 > 构建 > 静态

#### 4. 需求追溯（必需）
- 关联的需求ID或用户故事
- 使用 `_需求: FR-xxx_` 格式标注

**任务格式模板 (REQUIRED)**：

每个任务 **MUST** 严格遵循以下格式：

```markdown
- [ ] N. 任务标题
  - 关键要点1
  - 关键要点2
  - **验证方法**: 【验证方式】具体验证步骤
  - _需求: FR-xxx, FR-yyy_
```

**格式组件说明**：
1. **复选框**: 必须以 `- [ ]` 开头（markdown 复选框）
2. **任务编号**: 顺序数字（1. 2. 3...），按执行顺序排列
3. **任务标题**: 简洁描述任务目标
4. **关键要点**: 使用子项列出实现要点
5. **验证方法**: 使用粗体标注，包含【验证方式】标签
6. **需求追溯**: 使用斜体标注关联的需求ID

**✅ 正确格式示例**：
```markdown
- [ ] 1. 创建用户认证模块
  - 实现用户登录功能
  - 实现 JWT Token 生成和验证
  - **验证方法**: 【运行时验证】启动应用，调用登录API，验证Token返回
  - _需求: FR-001, FR-002_
```

**❌ 错误格式示例**：
```markdown
- [ ] 1.1 创建用户认证模块  // 错误：使用了分层编号
- [ ] Create user auth module  // 错误：缺少验证方法和需求追溯
T001 创建用户认证模块  // 错误：缺少复选框
```

**任务编号规范**：
- ✅ **正确格式**：`- [ ] 1. 创建 Maven 父工程`
- ❌ **错误格式**：`- [ ] 1.1 创建 Maven 父工程`
- **原因**：分层编号会导致任务执行按钮无法显示

**✅ 第三步完成标志**：
- 所有任务都有清晰的描述
- 所有任务都有可执行的验收标准
- 所有任务都标注了验证方式
- 所有任务都关联了需求ID

**过渡到第四步**：
> "任务描述已完成。现在进入第四步：任务列表验证。"

---

### 第四步：任务列表验证（必选）

**🎯 步骤目标**：对任务列表进行全面验证，确保质量

**⚠️ 重要**：这一步是**必选**的，不能跳过！任务列表验证对于确保任务质量至关重要。

**⚠️ 重要**：在开始这一步时，我应该明确告知用户：
> "我们现在开始第四步：任务列表验证。我会从一致性、可执行性、可验证性三个维度进行检查。"

**验证维度**：

#### 1. 与需求和设计的一致性
- [ ] 任务列表是否与需求和设计一致？
- [ ] 是否有超出设计范围的任务？
- [ ] 是否完整覆盖了设计中的所有内容？
- [ ] 是否有遗漏的功能或模块？

#### 2. 任务的可执行性
- [ ] 每个任务的目标是否明确？
- [ ] 任务的粒度是否合适（1-4 小时）？
- [ ] 任务之间的依赖关系是否清晰？
- [ ] 是否有循环依赖？

#### 3. 任务的可验证性
- [ ] 每个任务的验证标准是否明确？
- [ ] 验证标准是否具体、可执行？
- [ ] 验证方法是否可操作？
- [ ] 是否明确了验证优先级（运行时 > 单元测试 > 构建 > 静态）？

#### 4. 任务格式规范性
- [ ] 所有任务都使用简单数字编号（1. 2. 3.）？
- [ ] 所有任务都有【验证方式】标签？
- [ ] 所有任务都有需求追溯（_需求: xxx_）？

**验证结果报告模板**：

```markdown
## 任务列表验证报告

### 一致性检查
- 设计覆盖率: [X]% ([N]/[M] 设计点已覆盖)
- 超范围任务: [无/列表]
- 遗漏内容: [无/列表]

### 可执行性检查
- 任务总数: [N]
- 粒度合适: [N]/[总数]
- 循环依赖: [无/有]

### 可验证性检查
- 有验证标准: [N]/[总数]
- 验证方式明确: [N]/[总数]

### 格式规范性检查
- 格式正确: [N]/[总数]
- 格式问题: [列表，如有]

### 验证结果
- [ ] ✅ 验证通过
- [ ] ⚠️ 需要修正（列出问题）
```

**验证失败处理**：
- **If 存在超范围任务**: 移除超出设计范围的任务
- **If 存在遗漏内容**: 补充遗漏的任务
- **If 存在循环依赖**: 调整任务依赖关系
- **If 格式不正确**: 修正任务格式

**重试机制**：
- 如果验证失败，修正问题后重新验证
- 最多重试3次
- 如果3次后仍有问题，记录问题并警告用户

**✅ 第四步完成标志**：
- 一致性检查通过
- 可执行性检查通过
- 可验证性检查通过
- 格式规范性检查通过
- 验证报告已生成

**过渡到第五步**：
> "任务列表验证通过。现在进入第五步：需求追溯验证。"

---

### 第五步：需求追溯验证（必选）

**🎯 步骤目标**：确保任务与需求之间的完整双向追溯

**⚠️ 重要**：这一步是**必选**的，不能跳过！需求追溯对于确保任务完整性和防止范围蔓延至关重要。

**⚠️ 重要**：在开始这一步时，我应该明确告知用户：
> "我们现在开始第五步：需求追溯验证。我会创建追溯矩阵，确保每个需求都有对应的任务。"

**我的责任**：
作为专业的任务规划师，我必须创建并验证完整的需求-任务追溯矩阵，以确保：
1. 每个需求都有对应的任务（正向追溯）
2. 每个任务都能追溯到需求（反向追溯）
3. 没有需求被遗漏
4. 没有未经授权的任务被添加

#### 5.1 正向追溯（需求 → 任务）

**我必须验证的内容**：

对于 spec.md 中的**每个功能性需求**：
- [ ] 识别哪些任务覆盖了此需求
- [ ] 验证任务是否充分覆盖了需求
- [ ] 记录映射关系

**正向追溯矩阵模板**：

| 需求ID | 需求描述 | 任务ID | 覆盖度 | 备注 |
|--------|---------|--------|--------|------|
| FR-001 | [功能需求1] | T1, T2 | 完全/部分 | |
| FR-002 | [功能需求2] | T3 | 完全/部分 | |

**覆盖度评估**：
- **完全**：需求被任务完全覆盖
- **部分**：需求被部分覆盖，已识别差距
- **无**：需求未被覆盖（严重 - 必须解决）

#### 5.2 反向追溯（任务 → 需求）

**我必须验证的内容**：

对于**每个任务**：
- [ ] 识别哪些需求证明了此任务的合理性
- [ ] 如果找不到需求，标记为潜在范围蔓延
- [ ] 记录映射关系

**反向追溯矩阵模板**：

| 任务ID | 任务描述 | 追溯到的需求 | 合理性状态 |
|--------|---------|-------------|-----------|
| T1 | [任务描述] | FR-001, FR-003 | 已验证 |
| T2 | [任务描述] | FR-002 | 已验证 |
| T3 | [任务描述] | ??? | ⚠️ 无需求 |

**合理性状态**：
- **已验证**：任务明确追溯到需求
- **推断**：任务间接支持需求（可接受，需解释）
- **无需求**：找不到需求依据（必须与用户确认或移除）

#### 5.3 追溯报告

**追溯汇总指标**：

| 指标 | 值 | 目标 | 状态 |
|------|---|------|------|
| 总需求数 | N | - | - |
| 完全覆盖的需求 | N | 100% | ✅/❌ |
| 部分覆盖的需求 | N | 0 | ✅/⚠️ |
| 未覆盖的需求 | N | 0 | ✅/❌ |
| 总任务数 | N | - | - |
| 已验证的任务 | N | 100% | ✅/❌ |
| 无依据的任务 | N | 0 | ✅/⚠️ |

**追溯报告模板**：
```markdown
"需求追溯验证已完成。总结：

**正向追溯（需求 → 任务）**：
- 总需求数：[N]
- 完全覆盖：[N] ([X]%)
- 部分覆盖：[N] ([X]%) - [列表，如有]
- 未覆盖：[N] ([X]%) - [列表，如有 - 严重]

**反向追溯（任务 → 需求）**：
- 总任务数：[N]
- 已验证：[N] ([X]%)
- 推断：[N] ([X]%) - [列表及解释]
- 无依据：[N] ([X]%) - [列表 - 必须解决]

**追溯矩阵**：[完整矩阵在 tasks.md 中]

**必要行动**：
1. [行动1] - [优先级]
2. [行动2] - [优先级]"
```

**强制行动**：
- 如果任何需求"无"覆盖：必须添加任务或与用户澄清
- 如果任何任务"无依据"：必须获得用户确认或移除
- 如果追溯覆盖率 < 100%：必须记录并说明差距原因

**✅ 第五步完成标志**：
- 正向追溯矩阵已完成
- 反向追溯矩阵已完成
- 所有未覆盖的需求已解决
- 所有无依据的任务已确认或移除
- 追溯报告已生成

**过渡到第六步**：
> "需求追溯验证完成。现在进入第六步：用户确认。"

---

### 第六步：用户确认（必选）

**🎯 步骤目标**：获得用户对最终任务列表的明确认可

**⚠️ 重要**：这一步是**必选**的！在用户明确认可之前，不能开始任务执行！

**⚠️ 重要**：在开始这一步时，我应该明确告知用户：
> "任务规划已完成，等待您的确认。请审阅任务列表，确认后我将开始执行。"

**我应该如何寻求确认**：

1. **提供清晰的摘要**
   ```
   示例：
   "任务规划已完成，主要内容摘要：

   **任务总数**：[N] 个任务
   **预估总工时**：[X-Y] 小时

   **任务分布**：
   - 基础设施任务：[N] 个
   - 数据层任务：[N] 个
   - 业务层任务：[N] 个
   - 接口层任务：[N] 个

   **验证报告**（第四步）：
   - 一致性：✅ 通过
   - 可执行性：✅ 通过
   - 可验证性：✅ 通过

   **追溯报告**（第五步）：
   - 需求覆盖率：100%
   - 任务合理性：100%

   **任务列表**：`.kiro/features/{feature-id}/tasks.md`

   请审阅任务列表，确认后我将开始执行。是否可以开始？"
   ```

2. **明确需要确认的关键点**
   - 任务拆分的粒度是否合适
   - 任务优先级和顺序是否合理
   - 是否有遗漏或不必要的任务
   - 验收标准是否清晰可行

3. **处理用户反馈**
   - 如果用户同意：感谢确认，准备开始任务执行
   - 如果用户有疑问：耐心解释任务设计理由
   - 如果用户要求修改：理解修改原因，更新任务列表，重新验证
   - 如果用户提出新需求：建议先回到设计阶段更新设计文档

**确认标准**：
只有在以下情况下，我才能开始任务执行：
- ✅ 用户明确表示同意任务列表
- ✅ 所有用户提出的问题已解答
- ✅ 所有修改意见已落实到任务列表
- ✅ 没有悬而未决的问题

**禁止行为**：
- ❌ 不要在没有用户确认的情况下就开始任务执行
- ❌ 不要假设用户同意（"如果没有意见，我就继续了"）
- ❌ 不要对用户的反馈表现出不耐烦

**✅ 第六步完成标志（任务规划阶段完成）**：
- 用户已明确表示认可任务列表
- 所有用户反馈已处理
- 任务列表已更新到最终版本
- 没有悬而未决的问题

**🎉 任务规划阶段完成**：
当获得用户明确认可后，我应该明确告知：
> "感谢您的确认！任务规划阶段已完成。
>
> **任务规划阶段总结**：
> - ✅ 设计方案理解
> - ✅ 任务列表创建
> - ✅ 任务描述编写
> - ✅ 任务列表验证（第四步）
> - ✅ 需求追溯验证（第五步）
> - ✅ 用户确认完成
>
> 任务列表已输出到 `.kiro/features/{feature-id}/tasks.md`
>
> 现在可以开始任务执行。"

**⚠️ 关键提醒**：只有完成以上6个步骤并获得用户认可后，才能开始任务执行！

---

## 验收原则

**核心要求**：每个验收标准都必须明确标注验证方式，使用【验证方式】标签。

任务验收应遵循以下优先级顺序：

### 1. 【运行时验证】（最优先）
能通过实际运行应用来验证的功能，必须通过运行应用进行验证。

**适用场景**：
- 配置验证（多环境、特性开关等）
- API 端点功能验证
- 日志输出格式验证
- 异常处理验证
- 集成功能验证
- 外部服务连接验证

**验证方法**：
- 启动应用（使用项目的启动命令）
- 访问相关端点或触发相关功能
- 检查实际运行结果是否符合预期

### 2. 【单元测试】（次优先）
业务逻辑和算法应该通过单元测试验证。

**适用场景**：
- Service 层业务逻辑
- 工具类方法
- 算法实现
- 数据转换逻辑

**验证方法**：
- 执行单元测试命令（如 `mvn test`）
- 检查测试覆盖率
- 验证所有测试用例通过

### 3. 【构建验证】（第三优先）
无法通过运行验证的结构性要求，通过构建项目进行验证。

**适用场景**：
- 模块/组件结构验证
- 依赖关系验证
- 构建配置验证
- 代码语法正确性验证

**验证方法**：
- 执行项目的构建命令确保构建成功
- 检查构建日志中的组件顺序和依赖关系
- 确认构建产物符合预期

### 4. 【静态检查】（最后）
仅在无法通过上述方式验证时，才使用静态文件检查。

**适用场景**：
- 文件存在性检查
- 配置文件内容检查
- 目录结构检查

**验证方法**：
- 检查文件是否存在
- 检查文件内容是否符合要求

**验证方式选择原则**：

优先选择更高层次的验证方式：
- 能运行验证的，不用单元测试
- 能单元测试的，不用构建验证
- 能构建验证的，不用静态检查
- 一个任务可以包含多种验证方式

---

## 任务描述的三个层次

**核心原则**：任务描述应该是"做什么"，而不是"怎么做"

任务拆分的目标是将设计转化为可执行的目标，而不是编写详细的编码指令。任务应该描述要达成的结果，而不是逐步的实现细节。

### 1. 目标层（推荐）✅

**特点**：描述要达成的结果，不涉及具体实现步骤

**适用场景**：大部分任务

**优点**：
- 给执行者留有实现空间
- 关注结果而非过程
- 避免过度细节化

**示例**：
```markdown
✅ 正确：
- [ ] 1. 实现用户认证功能
  - 支持用户名密码登录
  - 生成和验证JWT Token
  - **验证方法**: 【运行时验证】调用登录API验证Token返回
  - _需求: FR-001_
```

### 2. 步骤层（谨慎使用）⚠️

**特点**：列出主要步骤，但不涉及具体的代码细节

**适用场景**：复杂任务需要明确子步骤时

**注意事项**：
- 步骤应该是高层次的
- 避免涉及具体的配置项或代码行
- 保持在"做什么"的层面

### 3. 细节层（避免使用）❌

**特点**：详细到每个配置项、每行代码

**问题**：这是编码指令，不是任务描述，与直接编码没有区别

**示例**：
```markdown
❌ 错误（过于详细）：
- [ ] 1. 实现用户认证功能
  - 在 AuthController.java 第45行添加 @PostMapping("/login")
  - 创建 LoginRequest DTO 包含 username 和 password 字段
  - 在 AuthService.java 中实现 authenticate() 方法
  - 使用 BCryptPasswordEncoder 进行密码验证
  - 调用 JwtUtil.generateToken() 生成Token
```

---

## 任务粒度的把握

### 合适的任务粒度

**单个任务应该**：
- 可以在 1-4 小时内完成
- 有明确的开始和结束
- 可以独立验证
- 产生可见的成果

### 任务过大的信号

- 需要超过 4 小时完成
- 包含多个不相关的功能
- 难以定义验收标准

**解决方案**：拆分为子任务

### 任务过小的信号

- 只需要几分钟完成
- 只是一个配置项或一行代码
- 无法独立验证

**解决方案**：合并到相关任务中

---

## 常见问题与应对

### 问题 1：任务粒度过大

**表现**：任务需要超过 4 小时完成，包含多个不相关的功能，难以定义验收标准。

**应对**：
- 将大任务拆分为多个子任务
- 每个子任务关注一个明确的目标
- 确保每个子任务可以独立验证

### 问题 2：任务粒度过小

**表现**：任务只需要几分钟完成，只是一个配置项或一行代码，无法独立验证。

**应对**：
- 将小任务合并到相关任务中
- 作为大任务的一个步骤或验收点
- 保持任务的独立性和完整性

### 问题 3：任务描述过于详细

**表现**：任务描述包含具体的代码实现、配置细节，读起来像编码指令。

**应对**：
- 任务应该描述"做什么"，而非"怎么做"
- 关注目标和结果，而非实现过程
- 给执行者留有实现空间
- 将实现细节留给编码阶段

### 问题 4：验收标准不明确

**表现**：验收标准模糊，无法判断任务是否完成，缺乏具体的验证方法。

**应对**：
- 提供具体的验证命令和步骤
- 明确预期的输出和结果
- 指定验证方法（运行时/单元测试/构建/静态）
- 使用【验证方式】标签明确标注

---

## 优秀任务示例

以下是一个符合最佳实践的任务示例，展示了标准的任务格式：

### 示例：创建图构建器核心功能

```markdown
- [ ] 4. 创建图构建器核心功能
  - 编写 GraphBuilder 类使用 LangGraph 技术构建协作图
  - 实现团队图和监督者图的构建方法
  - 创建节点和边的定义逻辑
  - **验证方法**: 【运行时验证】测试图构建成功，验证节点和边的正确性，检查 LangGraph 编译无错误
  - _需求: FR-001, FR-003_
```

**示例分析**：

1. **任务标识清晰**：使用简单数字编号（4.）便于引用和跟踪
2. **目标明确**：创建图构建器核心功能
3. **关键要点列举**：
   - 使用 LangGraph 技术构建协作图
   - 实现团队图和监督者图的构建方法
   - 创建节点和边的定义逻辑
4. **验证方法明确**：
   - 标注【运行时验证】
   - 测试图构建成功
   - 验证节点和边的正确性
   - 检查 LangGraph 编译无错误
5. **需求追溯**：明确关联需求 FR-001 和 FR-003

**为什么这是好的任务**：
- ✅ 描述"做什么"而非"怎么做"
- ✅ 目标清晰，范围明确
- ✅ 验证标准具体可执行
- ✅ 粒度合适（预计 2-3 小时）
- ✅ 可独立验证
- ✅ 与需求可追溯

---

## 检查清单

在开始执行任务前，确认以下所有项：

### 设计理解
- [ ] 已充分理解设计文档（design.md）
- [ ] 已识别核心功能和依赖关系
- [ ] 已标记技术难点和风险点

### 任务列表
- [ ] 已创建完整的任务列表
- [ ] 每个任务都有明确的目标和验收标准
- [ ] 任务描述关注"做什么"而不是"怎么做"
- [ ] 任务粒度合适（1-4 小时可完成）
- [ ] 任务之间的依赖关系清晰
- [ ] 使用简单数字编号（1. 2. 3.）

### 验收标准
- [ ] 验收标准具体、可执行、可测试
- [ ] 每个任务都有【验证方式】标签
- [ ] 按验证优先级选择验证方式

### 任务列表验证（必选 - 第四步）
- [ ] 一致性检查通过
- [ ] 可执行性检查通过
- [ ] 可验证性检查通过
- [ ] 格式规范性检查通过

### 需求追溯验证（必选 - 第五步）
- [ ] 正向追溯矩阵已完成
- [ ] 反向追溯矩阵已完成
- [ ] 所有需求都有对应的任务
- [ ] 所有任务都能追溯到需求
- [ ] 无未覆盖的需求
- [ ] 无无依据的任务

### 用户确认（必选 - 第六步）
- [ ] 已向用户提供任务列表摘要
- [ ] 已报告验证结果
- [ ] 已报告追溯结果
- [ ] 已获得用户对任务列表的明确认可

**只有当所有检查项都完成后，我才能开始任务执行。**

---

## 任务拆分的黄金法则

1. **任务描述要抽象**：说明要达成什么目标，而非如何实现
2. **验收标准要具体**：说明如何验证目标达成，提供具体步骤
3. **避免编码指令**：不要逐行告诉执行者怎么写代码
4. **关注结果而非过程**：描述要产生什么，而不是如何产生
5. **保持合适粒度**：1-4 小时可完成，可独立验证
6. **需求可追溯**：每个任务都关联到具体需求

---

## 关键收益

遵循任务规划阶段最佳实践，可以：

- ✅ 确保任务可执行性，降低实施风险
- ✅ 提高开发效率和质量
- ✅ 便于进度跟踪和风险控制
- ✅ 支持并行开发和增量交付
- ✅ 确保交付物的可验证性
- ✅ 确保需求的完整覆盖

**记住**：任务是给开发者的目标指引，不是给 AI 的编码指令。如果任务描述读起来像是在写代码，那就说明太详细了。

---

## 🎯 最重要的提醒

**我必须严格按照以下6个步骤的顺序执行，这是强制性的要求：**

1. **第一步：理解设计方案** → 理解完成
2. **第二步：创建任务列表** → 任务已创建
3. **第三步：编写任务描述** → 描述已完成
4. **第四步：任务列表验证（必选）** → 验证通过
5. **第五步：需求追溯验证（必选）** → 追溯完成
6. **第六步：用户确认（必选）** → 用户认可

**只有完成所有6个步骤，才能开始任务执行！**

**每个步骤我都应该主动告知用户当前进度**，例如：
- "我们现在进入第二步：创建任务列表..."
- "任务列表已创建，进入第三步：编写任务描述..."
- "现在进入第四步：任务列表验证..."
- "现在进入第五步：需求追溯验证..."
- "验证完成，进入第六步：用户确认..."

**禁止的行为**：
- ❌ 跳过任何步骤
- ❌ 打乱执行顺序
- ❌ 在没有完成验证的情况下进入用户确认
- ❌ 在没有用户确认的情况下开始任务执行
- ❌ 跳过任务列表验证（第四步）- 这是必选步骤
- ❌ 跳过需求追溯验证（第五步）- 这是必选步骤
- ❌ 跳过用户确认（第六步）- 这是必选步骤

---

*本文档指导AI严格按照6步流程（第4、5、6步为必选）系统化地完成任务规划工作。*
