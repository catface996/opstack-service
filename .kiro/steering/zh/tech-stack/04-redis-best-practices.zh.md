---
inclusion: manual
---

# Redis 最佳实践

本文档指导 AI 如何正确、高效、安全地使用 Redis 缓存。

## 快速参考

| 规则 | 要求 | 优先级 |
|------|------|--------|
| 过期时间 | MUST 为所有缓存设置过期时间 | P0 |
| Key 命名 | MUST 使用 业务:功能:ID 格式 | P0 |
| 大 Key | NEVER 单个 Value 超过 10KB | P0 |
| 缓存策略 | MUST 先更新数据库后删除缓存 | P0 |
| 防护机制 | MUST 实现缓存穿透/击穿/雪崩防护 | P1 |

## 关键规则 (NON-NEGOTIABLE)

| 规则 | 描述 | ✅ 正确 | ❌ 错误 |
|------|------|---------|---------|
| **过期时间** | 所有缓存必须设置 TTL | `setex key 3600 value` | `set key value`（无过期时间） |
| **Key 命名** | 使用冒号分隔层级，见名知意 | `user:info:1001` | `u1001` 或 `userInfo1001` |
| **大 Key 限制** | 单个 Value 不超过 10KB | 拆分或使用 Hash | 存储 1MB 的 JSON |
| **缓存更新** | 先更新数据库，再删除缓存 | `update DB → delete cache` | `update cache → update DB` |
| **批量操作** | 使用 Pipeline 或 MGET/MSET | `mget key1 key2 key3` | 循环执行 `get key` |

## 核心原则

### 1. 缓存设计原则

**你必须遵守**：
- ✅ 缓存应该是可选的（系统在缓存失效时仍能正常运行）
- ✅ 设置合理的过期时间（避免内存溢出）
- ✅ 使用合适的数据结构（提高性能）
- ❌ 不要把 Redis 当作数据库使用（数据持久化应该在 MySQL）

### 2. 性能优先原则

**你应该考虑**：
- 避免大 Key（单个 Key 的 Value 不超过 10KB）
- 避免热 Key（访问频率过高的 Key）
- 使用批量操作（减少网络开销）
- 合理使用 Pipeline（批量执行命令）

### 3. 安全可靠原则

**你应该确保**：
- 防止缓存穿透（查询不存在的数据）
- 防止缓存击穿（热点数据过期）
- 防止缓存雪崩（大量缓存同时过期）
- 保证缓存与数据库的一致性

## Key 命名规范

### 你应该遵循的命名规则

**命名格式**：`业务模块:功能:唯一标识`

**示例**：
- ✅ `user:info:1001`（用户信息）
- ✅ `order:detail:20240101001`（订单详情）
- ✅ `product:stock:SKU123`（商品库存）
- ✅ `session:token:abc123`（会话令牌）

**命名原则**：
- 使用冒号 `:` 分隔层级
- 使用小写字母和下划线
- 见名知意，便于管理
- 避免过长的 Key 名称

## 数据类型选择

### 你应该如何选择数据类型

| 数据类型 | 使用场景 | 示例 |
|---------|---------|------|
| **String** | 简单的键值对、计数器、分布式锁 | 用户信息、访问计数 |
| **Hash** | 对象存储、字段可独立更新 | 用户详情、商品信息 |
| **List** | 消息队列、时间线、最新列表 | 评论列表、操作日志 |
| **Set** | 去重、交集/并集/差集运算 | 标签、关注列表 |
| **ZSet** | 排行榜、带权重的集合 | 积分排行、热度排序 |

### 数据类型使用建议

**String 类型**：
- 适合：简单值、JSON 字符串、计数器
- 操作：SET、GET、INCR、DECR

**Hash 类型**：
- 适合：对象存储（字段较少时）
- 操作：HSET、HGET、HMGET、HINCRBY
- 优势：可以只更新部分字段

**List 类型**：
- 适合：消息队列、时间线
- 操作：LPUSH、RPUSH、LPOP、RPOP、LRANGE
- 注意：避免 List 过长（建议不超过 1000 个元素）

**Set 类型**：
- 适合：去重、集合运算
- 操作：SADD、SREM、SISMEMBER、SINTER、SUNION

**ZSet 类型**：
- 适合：排行榜、优先级队列
- 操作：ZADD、ZRANGE、ZREVRANGE、ZINCRBY

## 过期时间设置

### 你应该遵循的过期时间规则

**必须设置过期时间**：
- ✅ 所有缓存数据都应该设置过期时间
- ❌ 不要使用永久缓存（除非有特殊需求）

**过期时间建议**：
- 热点数据：5-30 分钟
- 普通数据：1-24 小时
- 冷数据：1-7 天
- 会话数据：30 分钟-2 小时

**避免缓存雪崩**：
- 在过期时间上增加随机值（如 ±5 分钟）
- 避免大量缓存同时过期

**示例**：
```java
// 基础过期时间 30 分钟，加上 0-5 分钟的随机值
long expireTime = 30 * 60 + random.nextInt(5 * 60);
redisTemplate.expire(key, expireTime, TimeUnit.SECONDS);
```

## 缓存更新策略

### 你应该遵循的更新策略

**Cache Aside Pattern（旁路缓存模式）**：
- 读取：先读缓存，缓存不存在则读数据库，然后写入缓存
- 更新：先更新数据库，然后删除缓存（而不是更新缓存）

**为什么删除而不是更新缓存**：
- 避免并发更新导致的数据不一致
- 减少不必要的缓存写入（如果数据不再被访问）

**更新流程**：
```
1. 更新数据库
2. 删除缓存
3. 下次读取时重新加载缓存
```

## 缓存问题防护

### 1. 防止缓存穿透

**问题**：查询不存在的数据，导致每次都查询数据库

**你应该使用的解决方案**：

**方案 1：缓存空值**
- 查询结果为空时，也缓存一个空值
- 设置较短的过期时间（如 5 分钟）

**方案 2：布隆过滤器**
- 在缓存前增加布隆过滤器
- 快速判断数据是否存在

### 2. 防止缓存击穿

**问题**：热点数据过期，大量请求同时访问数据库

**你应该使用的解决方案**：

**方案 1：互斥锁**
- 使用分布式锁，只允许一个请求查询数据库
- 其他请求等待缓存重建完成

**方案 2：热点数据永不过期**
- 逻辑过期：在缓存中存储过期时间
- 后台异步更新缓存

### 3. 防止缓存雪崩

**问题**：大量缓存同时过期，导致数据库压力激增

**你应该使用的解决方案**：

**方案 1：过期时间加随机值**
- 避免缓存同时过期

**方案 2：缓存预热**
- 系统启动时预先加载热点数据

**方案 3：多级缓存**
- 本地缓存 + Redis 缓存
- 降低 Redis 压力

## 分布式锁使用

### 你应该遵循的分布式锁规则

**基本要求**：
- 互斥性：同一时刻只有一个客户端能持有锁
- 安全性：只有持有锁的客户端才能释放锁
- 容错性：锁必须有过期时间，避免死锁

**实现方式**：

**方案 1：SET NX EX**
- 使用 SET key value NX EX seconds
- NX：只在 Key 不存在时设置
- EX：设置过期时间

**方案 2：Redisson**
- 使用 Redisson 框架
- 自动续期、可重入锁

**注意事项**：
- 锁的过期时间要大于业务执行时间
- 释放锁时要验证是否是自己持有的锁
- 避免长时间持有锁

## 批量操作优化

### 你应该使用的批量操作方式

**Pipeline**：
- 批量发送命令，减少网络往返
- 适合：批量读取、批量写入

**MGET/MSET**：
- 批量获取/设置多个 Key
- 比多次 GET/SET 性能更好

**HMGET/HMSET**：
- 批量获取/设置 Hash 的多个字段

**注意事项**：
- 单次批量操作不要过多（建议不超过 100 个）
- 大批量操作应该分批进行

## 性能优化规范

### 你应该遵循的性能优化原则

**1. 避免大 Key**
- 单个 String 类型 Value 不超过 10KB
- Hash、List、Set、ZSet 元素数量不超过 5000

**2. 避免热 Key**
- 识别访问频率过高的 Key
- 使用本地缓存减轻 Redis 压力
- 考虑对热 Key 进行拆分

**3. 使用合适的数据结构**
- 根据业务场景选择最合适的数据类型
- 避免使用复杂的数据结构存储简单数据

**4. 合理使用持久化**
- RDB：适合备份、全量复制
- AOF：适合数据安全性要求高的场景
- 根据业务需求选择持久化策略

**5. 监控和告警**
- 监控内存使用率
- 监控慢查询
- 监控连接数
- 设置合理的告警阈值

## 常见使用场景

### 你应该了解的典型场景

**1. 缓存热点数据**
- 用户信息、商品详情、配置信息
- 减少数据库查询压力

**2. 计数器**
- 访问量统计、点赞数、库存数量
- 使用 INCR/DECR 原子操作

**3. 分布式锁**
- 防止重复提交、限流、定时任务
- 保证操作的互斥性

**4. 消息队列**
- 使用 List 实现简单队列
- 使用 Stream 实现消息队列（Redis 5.0+）

**5. 排行榜**
- 使用 ZSet 实现积分排行、热度排序
- 支持范围查询和分数更新

**6. 会话管理**
- 存储用户会话信息
- 支持分布式会话共享

**7. 限流**
- 使用计数器实现简单限流
- 使用滑动窗口实现精确限流

## Spring Boot 集成规范

### 你应该遵循的集成规则

**1. 使用 RedisTemplate**
- 配置序列化方式（推荐 JSON）
- 设置合理的连接池参数

**2. 使用 @Cacheable 注解**
- 简化缓存操作
- 注意缓存 Key 的生成规则

**3. 配置连接池**
- 最大连接数：根据并发量设置
- 最大空闲连接：避免频繁创建连接
- 连接超时时间：避免长时间等待

**4. 异常处理**
- Redis 异常不应该影响主业务
- 降级策略：Redis 不可用时直接查询数据库

## 常见错误和纠正方法

### 你应该避免的错误

| 错误类型 | 错误做法 | 正确做法 | 原因 |
|---------|---------|---------|------|
| **不设置过期时间** | 永久缓存 | 设置合理的过期时间 | 内存溢出 |
| **大 Key** | 单个 Value 超过 1MB | 拆分或使用 Hash | 性能问题 |
| **热 Key** | 单个 Key 访问过于频繁 | 使用本地缓存或拆分 | Redis 压力大 |
| **缓存穿透** | 不存在的数据不缓存 | 缓存空值或使用布隆过滤器 | 数据库压力大 |
| **缓存雪崩** | 大量缓存同时过期 | 过期时间加随机值 | 数据库压力激增 |
| **更新缓存** | 先更新缓存再更新数据库 | 先更新数据库再删除缓存 | 数据不一致 |
| **不使用批量操作** | 循环执行单个命令 | 使用 Pipeline 或 MGET | 性能差 |
| **分布式锁不设置过期时间** | 锁永不过期 | 必须设置过期时间 | 死锁 |

## 你的检查清单

在使用 Redis 时，你应该检查：

### 设计检查
- [ ] 所有缓存都设置了过期时间
- [ ] Key 命名符合规范（业务模块:功能:唯一标识）
- [ ] 选择了合适的数据类型
- [ ] 考虑了缓存穿透、击穿、雪崩的防护

### 性能检查
- [ ] 避免了大 Key（单个 Value < 10KB）
- [ ] 避免了热 Key（考虑本地缓存）
- [ ] 使用了批量操作（Pipeline、MGET）
- [ ] 集合类型元素数量合理（< 5000）

### 安全检查
- [ ] 缓存更新策略正确（先更新数据库，再删除缓存）
- [ ] 分布式锁设置了过期时间
- [ ] 释放锁时验证了锁的持有者
- [ ] Redis 异常有降级处理

### 可维护性检查
- [ ] Key 命名清晰，便于管理
- [ ] 过期时间设置合理
- [ ] 有监控和告警机制
- [ ] 有缓存预热和降级方案

## 关键原则总结

### 设计原则
1. **缓存是可选的**：系统在缓存失效时仍能正常运行
2. **必须设置过期时间**：避免内存溢出
3. **选择合适的数据类型**：提高性能和可维护性
4. **防护三大问题**：穿透、击穿、雪崩

### 性能原则
1. **避免大 Key**：单个 Value 不超过 10KB
2. **避免热 Key**：使用本地缓存或拆分
3. **使用批量操作**：减少网络开销
4. **合理使用持久化**：平衡性能和数据安全

### 安全原则
1. **先更新数据库，再删除缓存**：保证数据一致性
2. **分布式锁必须有过期时间**：避免死锁
3. **Redis 异常要降级**：不影响主业务
4. **监控和告警**：及时发现问题

## 关键收益

遵循这些规范，可以获得：

- ✅ 提高系统性能，减少数据库压力
- ✅ 保证缓存与数据库的一致性
- ✅ 防止缓存穿透、击穿、雪崩问题
- ✅ 避免内存溢出和性能问题
- ✅ 提高系统的可用性和稳定性
- ✅ 便于缓存的管理和维护
