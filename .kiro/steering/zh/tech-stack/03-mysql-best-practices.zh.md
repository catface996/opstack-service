---
inclusion: manual
---

# MySQL 最佳实践

本文档指导 AI 如何编写高质量、高性能、安全的 MySQL SQL 语句。

## 核心原则

### 1. 安全第一原则

**你必须遵守**：
- ❌ 永远不要使用字符串拼接构建 SQL（易受 SQL 注入攻击）
- ✅ 始终使用参数化查询（PreparedStatement 或 MyBatis 的 #{} 语法）
- ✅ 对用户输入进行验证和过滤

### 2. 性能优先原则

**你应该考虑**：
- 合理使用索引
- 避免全表扫描
- 减少数据传输量
- 优化查询逻辑

### 3. 可维护性原则

**你应该确保**：
- SQL 语句清晰易读
- 使用有意义的别名
- 适当添加注释
- 遵循命名规范

## SQL 编写规范

### 查询语句（SELECT）

**你应该遵循的规则**：

1. **明确指定列名**
   - ✅ `SELECT id, name, email FROM user`
   - ❌ `SELECT * FROM user`（除非确实需要所有列）

2. **使用表别名**
   - ✅ `SELECT u.id, u.name FROM user u`
   - 在多表查询时必须使用别名

3. **合理使用 WHERE 条件**
   - 将过滤性强的条件放在前面
   - 避免在 WHERE 子句中对列进行函数操作
   - ✅ `WHERE create_time >= '2024-01-01'`
   - ❌ `WHERE DATE(create_time) >= '2024-01-01'`（会导致索引失效）

4. **使用 LIMIT 限制结果集**
   - 分页查询必须使用 LIMIT
   - ✅ `SELECT * FROM user LIMIT 10 OFFSET 20`

5. **避免使用子查询（优先使用 JOIN）**
   - ✅ `SELECT u.* FROM user u JOIN order o ON u.id = o.user_id`
   - ⚠️ `SELECT * FROM user WHERE id IN (SELECT user_id FROM order)`（性能较差）

### 插入语句（INSERT）

**你应该遵循的规则**：

1. **明确指定列名**
   - ✅ `INSERT INTO user (name, email) VALUES (?, ?)`
   - ❌ `INSERT INTO user VALUES (?, ?, ?)`（不明确，易出错）

2. **批量插入优化**
   - ✅ `INSERT INTO user (name, email) VALUES (?, ?), (?, ?), (?, ?)`
   - ❌ 多次单条插入（性能差）

3. **使用 ON DUPLICATE KEY UPDATE**
   - 需要插入或更新时使用
   - `INSERT INTO user (id, name) VALUES (?, ?) ON DUPLICATE KEY UPDATE name = VALUES(name)`

### 更新语句（UPDATE）

**你应该遵循的规则**：

1. **必须有 WHERE 条件**
   - ✅ `UPDATE user SET name = ? WHERE id = ?`
   - ❌ `UPDATE user SET name = ?`（会更新所有记录，极其危险）

2. **避免更新大量数据**
   - 大批量更新应该分批进行
   - 使用 LIMIT 控制每批数量

3. **更新前先查询**
   - 确认影响的记录数
   - 避免误操作

### 删除语句（DELETE）

**你应该遵循的规则**：

1. **必须有 WHERE 条件**
   - ✅ `DELETE FROM user WHERE id = ?`
   - ❌ `DELETE FROM user`（会删除所有记录，极其危险）

2. **优先使用软删除**
   - ✅ `UPDATE user SET deleted = 1 WHERE id = ?`
   - 物理删除需谨慎

3. **删除前先查询**
   - 确认要删除的记录
   - 避免误删除

## 索引使用规范

### 你应该了解的索引规则

1. **索引生效的条件**
   - WHERE 条件使用索引列
   - 避免在索引列上使用函数
   - 避免使用 OR 连接条件（可能导致索引失效）
   - 使用覆盖索引减少回表

2. **索引失效的场景**
   - ❌ `WHERE YEAR(create_time) = 2024`（函数操作）
   - ❌ `WHERE name LIKE '%test%'`（前导模糊查询）
   - ❌ `WHERE age + 1 = 20`（列运算）
   - ❌ `WHERE name != 'test'`（不等于）

3. **联合索引的最左前缀原则**
   - 索引 (a, b, c) 可以支持：a、a+b、a+b+c
   - 不支持：b、c、b+c

### 你应该如何创建索引

**索引命名规范**：
- 主键索引：`pk_表名`
- 唯一索引：`uk_列名`
- 普通索引：`idx_列名`
- 联合索引：`idx_列名1_列名2`

**索引创建原则**：
- 频繁查询的列
- WHERE、ORDER BY、GROUP BY 中的列
- 区分度高的列
- 避免过多索引（影响写入性能）

## JOIN 查询规范

### 你应该遵循的 JOIN 规则

1. **明确 JOIN 类型**
   - INNER JOIN：只返回匹配的记录
   - LEFT JOIN：返回左表所有记录
   - RIGHT JOIN：返回右表所有记录（少用，可用 LEFT JOIN 替代）

2. **JOIN 条件必须使用索引**
   - ON 子句中的关联列应该有索引
   - 避免关联大表

3. **控制 JOIN 表的数量**
   - 建议不超过 3 个表
   - 过多 JOIN 影响性能

4. **小表驱动大表**
   - 将小表放在 JOIN 的左侧
   - 减少循环次数

## 事务使用规范

### 你应该遵循的事务规则

1. **事务范围最小化**
   - 只包含必要的操作
   - 避免长事务

2. **事务中避免的操作**
   - ❌ 远程调用（RPC、HTTP）
   - ❌ 复杂计算
   - ❌ 文件操作
   - ❌ 等待用户输入

3. **合理设置隔离级别**
   - READ COMMITTED：大多数场景
   - REPEATABLE READ：需要可重复读
   - SERIALIZABLE：极少使用

## MyBatis 使用规范

### 你应该遵循的 MyBatis 规则

1. **使用 #{} 而不是 ${}**
   - ✅ `WHERE id = #{id}`（参数化查询，安全）
   - ❌ `WHERE id = ${id}`（字符串拼接，不安全）
   - 例外：ORDER BY、表名、列名等必须使用 ${}

2. **合理使用 resultMap**
   - 字段名与属性名不一致时使用
   - 复杂对象映射时使用
   - 避免过度使用（简单查询用 resultType）

3. **避免 N+1 查询问题**
   - 使用 JOIN 或批量查询
   - 避免在循环中查询数据库

4. **使用动态 SQL**
   - `<if>`：条件判断
   - `<where>`：自动处理 WHERE 关键字
   - `<foreach>`：批量操作
   - `<choose>`：多条件选择

## 性能优化规范

### 你应该遵循的优化原则

1. **查询优化**
   - 只查询需要的列
   - 使用 LIMIT 限制结果集
   - 避免使用 DISTINCT（考虑用 GROUP BY）
   - 避免使用 HAVING（能用 WHERE 就用 WHERE）

2. **分页优化**
   - 深度分页使用延迟关联
   - ✅ `SELECT * FROM user WHERE id > #{lastId} LIMIT 10`
   - ⚠️ `SELECT * FROM user LIMIT 10000, 10`（深度分页性能差）

3. **COUNT 优化**
   - ❌ `SELECT COUNT(*) FROM user`（大表慢）
   - ✅ 使用缓存或预计算
   - ✅ 使用近似值（如果允许）

4. **批量操作优化**
   - 批量插入使用 VALUES 多行
   - 批量更新使用 CASE WHEN
   - 批量删除分批进行

## 数据类型选择规范

### 你应该遵循的类型选择原则

1. **整数类型**
   - TINYINT：-128 到 127（如状态、类型）
   - INT：-2^31 到 2^31-1（如 ID、数量）
   - BIGINT：-2^63 到 2^63-1（如大数据量 ID）

2. **字符串类型**
   - CHAR：固定长度（如手机号、身份证号）
   - VARCHAR：可变长度（如姓名、地址）
   - TEXT：大文本（如文章内容）

3. **日期时间类型**
   - DATE：日期（如生日）
   - DATETIME：日期时间（如创建时间）
   - TIMESTAMP：时间戳（自动更新）

4. **金额类型**
   - ✅ DECIMAL(10,2)：精确计算
   - ❌ FLOAT/DOUBLE：不精确，不适合金额

## 命名规范

### 你应该遵循的命名规则

1. **表名**
   - 小写字母，下划线分隔
   - 使用复数形式或业务含义
   - 示例：`user`, `order_item`, `product_category`

2. **列名**
   - 小写字母，下划线分隔
   - 见名知意
   - 示例：`user_id`, `create_time`, `order_status`

3. **索引名**
   - 主键：`pk_表名`
   - 唯一索引：`uk_列名`
   - 普通索引：`idx_列名`

4. **约束名**
   - 外键：`fk_表名_列名`
   - 检查约束：`ck_表名_列名`

## 常见错误和纠正方法

### 你应该避免的错误

| 错误类型 | 错误做法 | 正确做法 | 原因 |
|---------|---------|---------|------|
| **SQL 注入** | 字符串拼接 SQL | 使用参数化查询 | 安全风险 |
| **SELECT *** | `SELECT *` | 明确指定列名 | 性能和可维护性 |
| **无 WHERE 的 UPDATE/DELETE** | `UPDATE user SET ...` | 必须有 WHERE 条件 | 数据安全 |
| **索引失效** | `WHERE YEAR(time) = 2024` | `WHERE time >= '2024-01-01'` | 性能问题 |
| **N+1 查询** | 循环中查询数据库 | 使用 JOIN 或批量查询 | 性能问题 |
| **深度分页** | `LIMIT 10000, 10` | 使用延迟关联或游标 | 性能问题 |
| **长事务** | 事务中包含 RPC 调用 | 缩小事务范围 | 锁等待 |
| **使用 ${}** | `WHERE id = ${id}` | `WHERE id = #{id}` | SQL 注入风险 |

## 你的检查清单

在编写 SQL 时，你应该检查：

### 安全性检查
- [ ] 使用参数化查询（#{} 而不是 ${}）
- [ ] UPDATE/DELETE 语句有 WHERE 条件
- [ ] 没有直接拼接用户输入

### 性能检查
- [ ] 使用明确的列名而不是 SELECT *
- [ ] WHERE 条件使用索引列
- [ ] 避免在索引列上使用函数
- [ ] 使用 LIMIT 限制结果集
- [ ] 避免 N+1 查询问题

### 可维护性检查
- [ ] SQL 语句清晰易读
- [ ] 使用有意义的表别名
- [ ] 复杂 SQL 添加注释
- [ ] 遵循命名规范

### 正确性检查
- [ ] JOIN 条件正确
- [ ] WHERE 条件逻辑正确
- [ ] 数据类型匹配
- [ ] 考虑了 NULL 值处理

## 关键原则总结

### 安全原则
1. **永远使用参数化查询**：防止 SQL 注入
2. **UPDATE/DELETE 必须有 WHERE**：防止误操作
3. **验证用户输入**：防止恶意数据

### 性能原则
1. **合理使用索引**：提高查询速度
2. **避免全表扫描**：减少数据库负载
3. **批量操作优化**：减少网络开销
4. **控制事务范围**：减少锁等待

### 可维护性原则
1. **明确指定列名**：提高可读性
2. **使用有意义的别名**：便于理解
3. **遵循命名规范**：统一代码风格
4. **适当添加注释**：说明复杂逻辑

## 关键收益

遵循这些规范，可以获得：

- ✅ 防止 SQL 注入攻击，保证系统安全
- ✅ 提高查询性能，减少数据库负载
- ✅ 提高代码可读性和可维护性
- ✅ 减少 SQL 错误和数据问题
- ✅ 便于团队协作和代码审查
