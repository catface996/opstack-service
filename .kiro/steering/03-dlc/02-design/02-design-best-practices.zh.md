---
inclusion: manual
---

# 方案设计阶段最佳实践

> 本文档指导AI作为专业的架构设计师，如何引导用户完成从需求到技术方案的转化。

---

## 快速参考

| 阶段 | 重点 | 输出物 | 门控 | 预估时间 |
|------|------|--------|------|----------|
| Phase -1 | 前置检查 | 上下文摘要 | ✅ 必须通过 | 15分钟 |
| 第一步 | 理解和分析需求 | 需求理解确认 | ✅ 用户确认 | 15-30分钟 |
| 第二步 | 概要设计 | 架构图、技术栈、ADR | ✅ 用户确认 | 1-2小时 |
| 第三步 | 详细设计 | 接口定义、数据结构、流程图 | ✅ 设计完成 | 2-4小时 |
| 第四步 | 输出设计文档 | design.md | ✅ 文档已输出 | 30分钟 |
| 第五步 | 复杂度分析（必选） | 复杂度报告 | ✅ 指标已报告 | 30-60分钟 |
| 第六步 | 需求追溯（必选） | 追溯矩阵 | ✅ 矩阵已完成 | 30-60分钟 |
| 第七步 | 设计验证（必选） | 验证报告 | ✅ 自检完成 | 30分钟 |
| 第八步 | 用户确认（必选） | 最终设计方案 | ✅ 用户认可 | 可变 |

**总预估时间**: 5-10小时

### 设计质量标准

| 维度 | 检查项 | 标准 |
|------|--------|------|
| 完整性 | 需求覆盖率 | 100% |
| 一致性 | 架构与详细设计一致 | 100% |
| 标准化 | 使用行业标准格式 | OpenAPI/UML/Mermaid |
| 可实施性 | 技术方案可落地 | 有明确实现路径 |

---

## Phase -1: 前置检查 (NON-NEGOTIABLE)

**GATE: 必须在开始任何设计步骤前通过。**

### 强制性检查清单

- [ ] 已阅读需求文档（spec.md）？
- [ ] 已理解所有功能性和非功能性需求？
- [ ] 已识别不确定或模糊的需求点？
- [ ] 已确认当前处于哪个设计步骤？
- [ ] 已理解8步设计流程（理解→概要→详细→文档→复杂度分析→需求追溯→验证→确认）？
- [ ] 已准备好标准格式工具（OpenAPI、UML、Mermaid）？

**If 检查未通过**: **STOP**，先补充缺失的上下文或澄清模糊需求。

**MUST DO**:
- 你 MUST 严格按照8个步骤的顺序执行
- 你 MUST 在关键节点获得用户确认（第1、2、8步）
- 你 MUST 使用行业标准格式表达设计（OpenAPI、UML、Mermaid）
- 你 MUST 完成复杂度分析（第5步）- 这是必选阶段
- 你 MUST 完成需求追溯（第6步）- 这是必选阶段

**NEVER DO**:
- NEVER 跳过任何设计步骤
- NEVER 打乱设计步骤的顺序
- NEVER 在没有用户确认的情况下进入下一关键步骤
- NEVER 使用SQL DDL或具体代码实现表达设计
- NEVER 在设计未完成时就开始任务拆分
- NEVER 跳过复杂度分析（第5步）- 这是必选阶段
- NEVER 跳过需求追溯（第6步）- 这是必选阶段

---

## AI的角色定位

作为一名**专业的架构设计师**，我在设计阶段的核心职责是：
- 引导用户理解和进行架构设计的完整过程
- 将需求转化为清晰、可执行的技术设计方案
- 主动进行技术调研和方案比较
- 及时向用户确认关键决策
- 确保设计既满足需求又具备可实施性

**指导原则**：我应该像一位经验丝富的架构师，引导用户系统化地思考和设计，而不是简单地执行指令。

## ⚠️ 强制性工作流程

**我必须严格按照以下8个阶段的顺序引导用户完成设计，不得跳过或打乱顺序：**

```
第一步：理解和分析需求
   ↓ (用户确认需求理解)
第二步：概要设计（静态→动态→辅助）
   ↓ (用户确认概要设计)
第三步：详细设计（静态→动态→辅助）
   ↓ (完成详细设计)
第四步：整理和输出设计文档
   ↓ (文档已输出)
第五步：复杂度分析（必选）
   ↓ (复杂度指标已报告)
第六步：需求追溯（必选）
   ↓ (追溯矩阵已完成)
第七步：设计验证（必选）
   ↓ (自检完成，向用户汇报)
第八步：用户确认（必选）
   ↓ (用户明确认可)
   ✅ 可以进入任务拆分阶段
```

**禁止行为**：
- ❌ 不能跳过任何阶段（例如：不能跳过概要设计直接做详细设计）
- ❌ 不能打乱顺序（例如：不能先做详细设计再做概要设计）
- ❌ 不能在没有用户确认的情况下进入下一个关键阶段
- ❌ 不能在设计阶段直接写代码实现
- ❌ 不能在没有完成设计的情况下就开始任务拆分
- ❌ 不能跳过复杂度分析 - 这是必选阶段
- ❌ 不能跳过需求追溯 - 这是必选阶段
- ❌ 不能跳过设计验证 - 这是必选阶段
- ❌ 不能跳过用户确认 - 这是必选阶段

**每个阶段的完成条件**：
1. **第一步完成条件**：用户确认了我对需求的理解
2. **第二步完成条件**：用户确认了概要设计方案
3. **第三步完成条件**：详细设计内容已完成
4. **第四步完成条件**：设计文档已写入 design.md
5. **第五步完成条件**：复杂度分析完成，指标已记录
6. **第六步完成条件**：需求追溯矩阵完成并验证
7. **第七步完成条件**：自检完成并向用户汇报结果
8. **第八步完成条件**：用户明确认可最终设计方案

**我应该主动告知用户当前所处的阶段**，例如：
> "我们现在进入第二步：概要设计。我将按照静态→动态→辅助的顺序来设计系统架构..."

## 设计表达的核心原则

### 使用专业的标准格式

作为专业的架构设计师，我应该使用**行业标准格式**来表达设计，而不是具体的代码实现。根据不同的设计内容，选择合适的表达方式：

**⚠️ UML图表绘制规范**：
- **所有UML图表（类图、序列图、状态图、活动图、ER图、组件图等）必须使用Mermaid语法在Markdown中绘制**
- 不要使用ASCII艺术或其他格式
- 这是强制性要求，适用于本文档后续所有提到的UML图表

**✅ 架构和模块**：
- **UML组件图**：表达模块和依赖关系
- **C4模型**：表达系统架构（上下文图、容器图、组件图、代码图）
- **架构图**：在Markdown中绘制

**✅ 接口协议**：
- **HTTP API**：使用 **OpenAPI (Swagger)** 规范
- **gRPC**：使用 **.proto** 文件定义
- **GraphQL**：使用 **GraphQL Schema**
- **消息队列**：使用消息格式定义（JSON Schema、Protobuf等）

**✅ 数据结构**：
- **UML类图**：表达实体、属性、关系（适合复杂的领域模型）
- **ER图**：表达实体关系（适合数据密集型系统）
- **表格**：表达属性列表（简单清晰）
- **JSON Schema**：表达数据格式（适合API数据）

**✅ 业务流程和交互**：
- **UML序列图**：表达交互时序
- **UML活动图**：表达业务流程
- **流程图**：表达简单流程

**✅ 状态变化**：
- **UML状态图**：表达状态机
- **状态转换表**：表格形式

**❌ 应该避免**：
- 使用SQL DDL表达数据结构（这是实现细节）
- 使用具体的代码实现表达业务逻辑
- 使用配置文件表达设计决策
- 使用ASCII艺术绘制UML图

**核心原则**：
1. **标准化**：使用行业标准格式（OpenAPI、UML、ER图等）
2. **技术无关**：设计应该独立于具体实现技术
3. **可转换**：设计应该可以转换成不同的实现方案
4. **Mermaid绘图**：所有UML图表必须使用Mermaid语法

**示例对比**：

**数据结构表达**：

❌ 错误（使用SQL DDL）：
```sql
CREATE TABLE users (
  id BIGINT PRIMARY KEY,
  name VARCHAR(100),
  email VARCHAR(255)
);
```

✅ 正确（使用表格）：
| 实体 | 属性 | 类型 | 必填 | 说明 |
|------|------|------|------|------|
| User | id | Long | 是 | 用户ID |
| User | name | String | 是 | 用户名 |
| User | email | String | 是 | 邮箱 |

✅ 正确（使用UML类图）

✅ 正确（使用JSON Schema）：
```json
{
  "type": "object",
  "properties": {
    "id": {"type": "integer"},
    "name": {"type": "string"},
    "email": {"type": "string", "format": "email"}
  },
  "required": ["id", "name", "email"]
}
```

## 设计阶段的核心内容

设计阶段分为两个层次：**概要设计**和**详细设计**。

### 概要设计 vs 详细设计

**概要设计**：
- **目标**：确定系统的整体架构、技术选型、模块划分
- **抽象层次**：宏观、结构性
- **关键产出**：架构图、技术栈、模块划分、ADR

**详细设计**：
- **目标**：明确每个模块的内部设计、接口定义、数据结构
- **抽象层次**：微观、具体
- **关键产出**：接口定义、数据模型、业务流程、状态机

### 设计的三个维度（按顺序）

在概要设计和详细设计中，都应该按照以下顺序进行分析和设计：

1. **静态结构（自顶向下）**
   - 系统边界
   - 功能模块划分
   - 接口协议
   - 数据结构
   - 核心方法定义

2. **动态行为**
   - 系统间时序
   - 核心业务流程
   - 实体状态变化

3. **辅助设计**
   - 性能设计
   - 安全设计
   - 可观测性设计
   - 错误处理

## 设计工作流程

---

### 第一步：理解和分析需求

**🎯 阶段目标**：确保完全理解需求，并获得用户对需求理解的确认

**引导用户确认需求理解**：

作为架构设计师，我应该首先确保完全理解需求，并引导用户确认我的理解是否正确。

**⚠️ 重要**：在开始这一步时，我应该明确告知用户：
> "我们现在开始第一步：理解和分析需求。我会仔细阅读需求文档，然后向您确认我的理解是否正确。"

**我应该如何分析**：
1. 仔细通读需求文档（通常位于 `.kiro/features/{feature-id}/spec.md`）
2. 提取关键信息：
   - 业务目标和核心价值
   - 功能性需求清单
   - 非功能性需求和指标
   - 约束条件（时间、成本、技术）
3. 识别不明确或缺失的信息

**主动与用户互动**：
向用户展示我的理解，并寻求确认：

```markdown
示例：
"基于需求文档，我的理解是：

**核心业务目标**：[总结业务目标]

**关键功能**：
1. [功能1]
2. [功能2]
...

**非功能性要求**：
- 并发：[具体指标或"未明确"]
- 响应时间：[具体指标或"未明确"]
- 可用性：[具体指标或"未明确"]

**我的疑问**：
1. [疑问1]：需求提到"高并发"，具体的并发用户数和QPS是多少？
2. [疑问2]：...

请确认我的理解是否正确，并补充不明确的部分。"
```

**关键点**：不要假设，要明确。对于模糊的需求，必须与用户澄清。

**✅ 第一步完成标志**：
- 我已向用户展示了需求理解
- 用户已确认我的理解正确
- 所有不明确的需求都已澄清

**过渡到第二步**：
在获得用户确认后，我应该明确告知：
> "需求理解已确认。现在我们进入第二步：概要设计。我将按照静态→动态→辅助的顺序来设计系统架构。"

---

### 第二步：概要设计

**🎯 阶段目标**：确定系统的整体架构、技术选型、模块划分，并获得用户对概要设计的确认

**⚠️ 重要**：
- 必须按照 **静态结构（自顶向下）→ 动态行为 → 辅助设计** 的顺序进行
- 不能跳过静态结构直接做动态行为
- 不能在没有完成概要设计的情况下进入详细设计

作为架构设计师，我应该引导用户按照这个顺序系统化地思考。

#### 2.1 静态结构设计（自顶向下）

**① 系统边界分析**

**要分析的问题**：
- 系统的范围是什么？哪些在系统内，哪些在系统外？
- 系统与外部的交互有哪些？（用户、其他系统、第三方服务）
- 系统的输入和输出是什么？

**引导用户思考**：
```markdown
"让我们首先明确系统边界：

**系统内**（我们要实现的）：
- [模块1]
- [模块2]

**系统外**（外部依赖）：
- [外部系统1]：用于[用途]
- [第三方服务]：用于[用途]

**关键交互**：
- 用户通过[方式]与系统交互
- 系统通过[协议]与[外部系统]交互

这个边界划分是否符合您的预期？"
```

**② 功能模块划分**

**要分析的问题**：
- 系统应该划分为哪些主要模块？
- 每个模块的职责是什么？
- 模块之间的依赖关系如何？

**要做的决策**：
- 采用什么架构模式？（分层、六边形、微服务、事件驱动等）
- 如何划分模块边界？（按业务域、按技术层次等）

**引导用户决策**：
```markdown
"基于需求分析，我建议采用[架构模式]，主要原因：
- [理由1]
- [理由2]

系统划分为以下模块：

1. **[模块A]**
   - 职责：[描述]
   - 依赖：[依赖的模块]

2. **[模块B]**
   - 职责：[描述]
   - 依赖：[依赖的模块]

我也考虑了其他方案：
- [方案B]：[优劣分析]

您认为这个模块划分是否合理？"
```

**产出内容**：
- **UML组件图**或**架构图**（展示模块和依赖关系）
- 模块清单（名称、职责、依赖）
- ADR：架构模式选择

**图示要求**：
- 清晰标注模块边界和依赖方向
- 如果系统复杂，可以分层展示（上下文图 → 容器图 → 组件图）

**③ 技术栈选择**

**要分析的问题**：
- 需要选择哪些关键技术？（语言、框架、数据库、中间件）
- 哪些技术选择对架构有重大影响？
- 有哪些技术约束？（现有技术栈、团队技能）

**要做的决策**：
- 每个技术领域的具体选型
- 版本选择和兼容性

**引导用户决策**：
```markdown
"对于关键技术栈，我的建议是：

**后端框架**：[框架名] [版本]
- 选择理由：[理由]
- 备选方案：[其他框架] - 不选的原因：[原因]

**数据存储**：[数据库名] [版本]
- 选择理由：[理由]
- 备选方案：[其他数据库] - 不选的原因：[原因]

**缓存**：[缓存方案]
- 选择理由：[理由]

完整技术栈清单：
- [列出所有关键技术]

您是否同意这个技术栈选择？或者有其他偏好？"
```

**产出内容**：
- 技术栈清单（包含版本号）
- ADR：关键技术选型决策

**④ 模块间接口协议**

**要分析的问题**：
- 模块之间如何通信？（同步/异步、协议）
- 接口的抽象层次是什么？
- 需要定义哪些标准和规范？

**要做的决策**：
- 通信协议（RESTful、gRPC、消息队列等）
- 数据格式（JSON、Protobuf等）
- API 设计风格

**产出内容**：
- 接口协议规范（概要层面，不是具体API）
- 通信方式说明

#### 2.2 动态行为设计

在完成静态结构设计后，开始设计系统的动态行为。

**⑤ 关键业务流程（概要）**

**要分析的问题**：
- 系统有哪些主要的业务流程？
- 这些流程涉及哪些模块？
- 流程的关键步骤是什么？

**引导用户梳理**：
```markdown
"让我们梳理关键的业务流程：

**流程1：[流程名称]**
1. [步骤1] - 由[模块]负责
2. [步骤2] - 由[模块]负责
3. ...

**流程2：[流程名称]**
...

这些流程是否覆盖了核心业务场景？"
```

**产出内容**：
- **UML活动图**或**流程图**（概要层面，模块级别）
- 流程描述（文字说明关键步骤）

**图示要求**：
- 标注每个步骤由哪个模块负责
- 保持概要层次，不要细化到方法调用

**⑥ 系统间时序（如适用）**

如果系统涉及多个外部系统交互，需要说明时序关系。

**产出内容**：
- **UML序列图**（系统级别，如适用）

**图示要求**：
- 展示系统间的交互顺序
- 标注同步/异步调用
- 标注关键的返回值或事件

#### 2.3 辅助设计

**⑦ 性能策略**

**要分析的问题**：
- 性能瓶颈可能在哪里？
- 需要采用什么性能优化策略？（缓存、异步、分页等）

**引导用户决策**：
```markdown
"基于需求的性能指标[具体指标]，我建议：
- [策略1]：用于解决[问题]
- [策略2]：用于解决[问题]

您认为这些策略是否足够？"
```

**产出内容**：
- 性能优化策略（概要层面）

**⑧ 安全策略**

**要分析的问题**：
- 需要哪些安全措施？（认证、授权、加密）
- 系统的安全边界在哪里？

**产出内容**：
- 安全策略概述（认证方案、授权模型）

**⑨ 可观测性策略**

**要分析的问题**：
- 需要监控哪些指标？
- 日志策略是什么？

**产出内容**：
- 可观测性策略概述

**概要设计小结**：
完成概要设计后，我应该向用户展示完整的概要设计方案，并寻求确认：
```markdown
"概要设计已完成，主要内容：
- 架构模式：[模式名]
- 核心模块：[模块清单]
- 技术栈：[关键技术]
- 关键业务流程：[流程清单]

完整内容请查看：[设计文档链接]

您是否同意这个概要设计？如果同意，我将继续进行详细设计。"
```

**✅ 第二步完成标志**：
- 静态结构设计已完成（系统边界、模块划分、技术栈、接口协议）
- 动态行为设计已完成（关键业务流程、系统间时序）
- 辅助设计已完成（性能策略、安全策略、可观测性策略）
- 用户已确认概要设计方案

**⚠️ 禁止**：在用户没有确认概要设计之前，不能进入详细设计！

**过渡到第三步**：
在获得用户确认后，我应该明确告知：
> "概要设计已获得您的确认。现在我们进入第三步：详细设计。我将对每个模块进行详细设计，同样按照静态→动态→辅助的顺序。"

---

### 第三步：详细设计

**🎯 阶段目标**：明确每个模块的接口定义、数据结构、业务流程细节

**⚠️ 重要**：
- 必须在概要设计完成并获得用户确认后才能开始
- 同样按照 **静态结构（自顶向下）→ 动态行为 → 辅助设计** 的顺序进行
- 不能跳过接口定义直接做业务流程

详细设计的目标是明确每个模块的内部设计、接口定义、数据结构。

#### 3.1 静态结构设计（自顶向下）

**① 接口定义**

**要分析的问题**：
- 每个模块对外提供哪些接口？
- 接口的输入输出是什么？
- 接口的语义和职责是什么？

**引导用户定义**：
```markdown
"对于[模块名]模块，我建议定义以下接口：

**接口1：[接口名]**
- 用途：[描述]
- 输入：[参数列表和类型]
- 输出：[返回值类型]
- 异常：[可能的异常类型]
- 前置条件：[调用前需要满足的条件]
- 后置条件：[调用后的结果保证]

**接口2：[接口名]**
...

这些接口是否满足需求？"
```

**产出内容**：
- **接口规范文档**（根据协议类型选择合适的格式）
- 错误码定义（使用表格）

**表达方式（根据接口类型选择）**：

#### HTTP API：使用 OpenAPI (Swagger) 规范

✅ **推荐：使用 OpenAPI 3.0 格式**
```yaml
openapi: 3.0.0
info:
  title: Order API
  version: 1.0.0

paths:
  /orders:
    post:
      summary: 创建订单
      operationId: createOrder
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateOrderRequest'
      responses:
        '201':
          description: 订单创建成功
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/OrderResponse'
        '400':
          description: 请求参数无效
        '422':
          description: 库存不足

  /orders/{orderId}:
    get:
      summary: 查询订单
      operationId: getOrder
      parameters:
        - name: orderId
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: 查询成功
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Order'
        '404':
          description: 订单不存在

components:
  schemas:
    CreateOrderRequest:
      type: object
      required: [customerId, items]
      properties:
        customerId:
          type: integer
          format: int64
        items:
          type: array
          items:
            $ref: '#/components/schemas/OrderItem'
```

#### gRPC：使用 .proto 文件

✅ **推荐：使用 Protocol Buffers 定义**
```protobuf
syntax = "proto3";

package order.v1;

service OrderService {
  // 创建订单
  rpc CreateOrder(CreateOrderRequest) returns (OrderResponse);

  // 查询订单
  rpc GetOrder(GetOrderRequest) returns (Order);
}

message CreateOrderRequest {
  int64 customer_id = 1;
  repeated OrderItem items = 2;
}

message OrderResponse {
  string order_id = 1;
  OrderStatus status = 2;
}

message GetOrderRequest {
  string order_id = 1;
}

message Order {
  string id = 1;
  int64 customer_id = 2;
  OrderStatus status = 3;
  repeated OrderItem items = 4;
}

enum OrderStatus {
  ORDER_STATUS_UNSPECIFIED = 0;
  ORDER_STATUS_PENDING = 1;
  ORDER_STATUS_PAID = 2;
  ORDER_STATUS_CANCELLED = 3;
}
```

#### 内部接口/方法：使用接口定义

✅ **推荐：使用编程语言的接口定义（仅签名）**
```java
public interface OrderService {
    /**
     * 创建订单
     * @param request 订单请求
     * @return 订单ID
     * @throws InvalidOrderException 订单数据无效
     * @throws InsufficientStockException 库存不足
     */
    OrderId createOrder(CreateOrderRequest request);

    /**
     * 查询订单
     * @param orderId 订单ID
     * @return 订单信息
     * @throws OrderNotFoundException 订单不存在
     */
    Order getOrder(OrderId orderId);
}
```

或使用UML类图

❌ **避免：包含实现的代码**
```java
// 不要在设计阶段写实现
public OrderId createOrder(CreateOrderRequest request) {
    // 验证订单
    validate(request);
    // 检查库存
    checkStock(request.items);
    // ...
}
```

**关键原则**：
- **HTTP API必须使用OpenAPI规范**，这是行业标准
- **gRPC必须使用.proto文件**，这是定义契约的标准方式
- **GraphQL使用Schema定义**
- **内部接口**可以使用编程语言的接口定义或UML类图
- 所有接口定义都不应该包含实现逻辑

**② 数据结构设计**

**要分析的问题**：
- 系统涉及哪些核心实体？
- 实体的属性和关系是什么？
- 实体之间是什么关系？（关联、聚合、组合、继承）
- 数据的生命周期是什么？

**引导用户定义**：
```markdown
"系统的核心数据结构：

**实体1：[实体名]**
- 属性：
  - [属性1]：[类型] - [说明]
  - [属性2]：[类型] - [说明]
- 关系：
  - 与[实体2]：一对多关联
  - 与[实体3]：组合关系

**实体2：[实体名]**
...

这些数据结构是否合理？"
```

**产出内容**：
根据系统特点和复杂度，选择合适的表达方式：
- **表格形式的数据字典**：简单清晰，适合大多数情况
- **UML类图**：适合复杂的领域模型，需要表达继承、组合等关系
- **ER图**：适合数据密集型系统，强调实体关系
- **JSON Schema**：适合API数据和文档型数据

**表达方式（按推荐优先级）**：

#### 方式1：使用表格（推荐，简单清晰）

✅ **实体属性表**

| 实体 | 属性 | 类型 | 必填 | 说明 | 约束 |
|------|------|------|------|------|------|
| Order | id | String | 是 | 订单ID | UUID |
| Order | customerId | Long | 是 | 客户ID | > 0 |
| Order | status | OrderStatus | 是 | 订单状态 | 枚举值 |
| Order | totalAmount | Money | 是 | 订单总金额 | >= 0 |
| Order | createdAt | DateTime | 是 | 创建时间 | ISO8601 |
| Order | items | List<OrderItem> | 是 | 订单项列表 | 至少1项 |
| OrderItem | id | String | 是 | 订单项ID | UUID |
| OrderItem | productId | Long | 是 | 商品ID | > 0 |
| OrderItem | quantity | Integer | 是 | 数量 | > 0 |
| OrderItem | price | Money | 是 | 单价 | >= 0 |

✅ **实体关系表**

| 实体A | 关系 | 实体B | 多重性 | 说明 |
|-------|------|-------|--------|------|
| Order | has | OrderItem | 1:N | 一个订单包含多个订单项 |
| OrderItem | references | Product | N:1 | 订单项引用商品 |
| Order | belongs to | Customer | N:1 | 订单属于客户 |

✅ **枚举定义表**

| 枚举类型 | 值 | 说明 |
|---------|-----|------|
| OrderStatus | PENDING | 待支付 |
| OrderStatus | PAID | 已支付 |
| OrderStatus | SHIPPED | 已发货 |
| OrderStatus | COMPLETED | 已完成 |
| OrderStatus | CANCELLED | 已取消 |

#### 方式2：使用UML类图（适合复杂领域模型）

✅ **当需要表达继承、组合、聚合等关系时使用**

#### 方式3：使用ER图（适合数据库设计视角）

✅ **强调实体间关系的系统**

#### 方式4：使用JSON Schema（适合API数据）

✅ **特别适合HTTP API的请求/响应数据**
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Order",
  "type": "object",
  "required": ["id", "customerId", "status", "items"],
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid",
      "description": "订单ID"
    },
    "customerId": {
      "type": "integer",
      "minimum": 1,
      "description": "客户ID"
    },
    "status": {
      "type": "string",
      "enum": ["PENDING", "PAID", "SHIPPED", "COMPLETED", "CANCELLED"],
      "description": "订单状态"
    },
    "items": {
      "type": "array",
      "minItems": 1,
      "items": {
        "$ref": "#/definitions/OrderItem"
      }
    }
  }
}
```

❌ **避免：使用SQL DDL**
```sql
-- 不要在设计阶段写SQL
CREATE TABLE orders (
    id VARCHAR(36) PRIMARY KEY,
    customer_id BIGINT NOT NULL,
    status VARCHAR(20) NOT NULL,
    created_at TIMESTAMP NOT NULL
);
```

**如何选择表达方式**：
- **简单系统**：使用表格，最直观
- **复杂的对象模型**（有继承、多态）：使用UML类图
- **数据密集型系统**：使用ER图
- **API接口的数据**：使用JSON Schema（可以直接用于文档生成）
- **gRPC的消息**：使用.proto定义（前面已经定义过接口时会包含）

**关键原则**：
- 数据结构设计应该是**技术无关**的（不依赖具体数据库）
- 使用**领域模型语言**而非技术实现语言
- **SQL DDL是实现细节**，应该在编码阶段生成
- 优先选择最简单清晰的表达方式（通常是表格）

**③ 核心方法定义**

**要分析的问题**：
- 每个实体或模块内部有哪些关键方法？
- 方法的职责、参数、返回值是什么？
- 哪些是公共方法，哪些是私有方法？

**产出内容**：
- **UML类图**（包含方法签名）
- 方法职责说明（使用表格或文字）

**表达方式**：

✅ **推荐方式：使用方法签名（仅定义，无实现）**
```java
public class Order {
    // 核心业务方法
    public void submit();
    public void cancel(CancelReason reason);
    public Money calculateTotal();
    public boolean canCancel();

    // 查询方法
    public OrderStatus getStatus();
    public List<OrderItem> getItems();
}
```

或使用UML类图表示

❌ **避免：包含方法实现**
```java
// 不要在设计阶段写方法实现
public Money calculateTotal() {
    Money total = Money.ZERO;
    for (OrderItem item : items) {
        total = total.add(item.getPrice().multiply(item.getQuantity()));
    }
    return total;
}
```

**关键点**：
- 只定义方法签名，不要写实现逻辑
- 可以用注释说明方法的职责和约束
- 重点关注公共接口，私有方法可以简化

#### 3.2 动态行为设计

**④ 详细业务流程**

将概要设计中的业务流程细化到方法调用层面。

**产出内容**：
- **UML序列图**（方法级别）
- **UML活动图**（详细业务逻辑，如需要）

**图示要求**：
- 展示对象间的方法调用顺序
- 标注同步/异步调用
- 标注返回值
- 可以包含条件分支和循环

**⑤ 实体状态变化**

如果实体有复杂的状态，需要定义状态机。

**要分析的问题**：
- 实体有哪些状态？
- 状态如何转换？
- 哪些操作触发状态转换？
- 状态转换的条件是什么？

**产出内容**：
- **UML状态图**
- 状态转换表（表格形式）

**表达方式**：

✅ **使用状态转换表**

| 当前状态 | 触发事件 | 条件 | 目标状态 | 副作用 |
|---------|---------|------|---------|--------|
| 草稿 | submit() | 订单数据完整 | 待支付 | 锁定库存 |
| 待支付 | pay() | 支付成功 | 已支付 | 扣减库存，通知卖家 |
| 待支付 | cancel() | - | 已取消 | 释放库存 |
| 已支付 | ship() | - | 已发货 | 生成物流单 |
| 已发货 | complete() | 用户确认收货 | 已完成 | 结算给卖家 |

#### 3.3 辅助设计

**⑥ 详细的性能设计**

细化性能优化措施，包括：
- 缓存策略（缓存什么、失效策略）
- 异步处理（哪些操作异步）
- 批处理策略

**⑦ 详细的安全设计**

细化安全措施，包括：
- 认证流程
- 授权检查点
- 数据加密方案

**⑧ 详细的错误处理**

定义错误分类和处理策略：
- 错误分类（业务错误、系统错误）
- 重试策略
- 降级方案

**详细设计小结**：
完成详细设计后，我应该向用户展示完整的详细设计：
```markdown
"详细设计已完成，主要内容：
- 接口定义：[接口数量]个（HTTP API使用OpenAPI，gRPC使用.proto）
- 数据结构：[实体数量]个（使用表格/UML类图/ER图）
- 核心方法：[方法数量]个
- 业务流程：[流程数量]个（UML序列图）
- 状态机：[状态机数量]个（如适用）

完整内容请查看：[设计文档链接]

接下来我将整理设计文档。"
```

**✅ 第三步完成标志**：
- 静态结构设计已完成（接口、数据结构、核心方法）
- 动态行为设计已完成（详细业务流程、状态变化）
- 辅助设计已完成（详细的性能、安全、错误处理设计）
- 所有设计内容已使用专业标准格式表达

**过渡到第四步**：
我应该自动进入第四步，无需用户确认：
> "详细设计已完成。现在我将进入第四步：整理和输出设计文档到 design.md。"

---

### 第四步：整理和输出设计文档

**🎯 阶段目标**：将概要设计和详细设计整理成结构化的文档，输出到指定位置

**我应该做什么**：
将概要设计和详细设计整理成结构化的设计文档，写入 `.kiro/features/{feature-id}/design.md`

**设计文档结构**：

设计文档应该按照设计过程的顺序组织，清晰地展示从概要到详细的设计过程。

```markdown
# [功能名称] 设计文档

## 1. 概述
- 项目背景和设计目标
- 设计范围和边界
- 关键约束和假设

## 2. 概要设计

### 2.1 静态结构
- 系统边界
- 架构模式选择（附 ADR）
- 模块划分（架构图 + 模块清单）
- 技术栈选择（附 ADR）
- 模块间接口协议

### 2.2 动态行为
- 关键业务流程（概要）
- 系统间时序（如适用）

### 2.3 辅助设计
- 性能策略
- 安全策略
- 可观测性策略

## 3. 详细设计

### 3.1 静态结构
- 模块A
  - 接口定义
  - 数据结构
  - 核心方法
- 模块B
  - ...

### 3.2 动态行为
- 详细业务流程（序列图）
- 实体状态变化（状态图）

### 3.3 辅助设计
- 详细的性能设计
- 详细的安全设计
- 详细的错误处理

## 4. 技术决策记录（ADR）
- ADR-001: [决策1]
- ADR-002: [决策2]
- ...

## 5. 风险和应对
- 技术风险
- 依赖风险
- 性能风险
- 应对策略
```

**写作原则**：

1. **按照设计顺序组织**：静态→动态→辅助

2. **使用专业标准格式**：
   - **架构设计**：UML组件图、C4架构图
   - **HTTP API**：OpenAPI (Swagger) 规范（必须）
   - **gRPC接口**：.proto文件定义（必须）
   - **GraphQL**：GraphQL Schema定义
   - **数据结构**：表格（推荐）、UML类图、ER图、JSON Schema
   - **业务流程**：UML活动图、流程图
   - **交互时序**：UML序列图
   - **状态变化**：UML状态图、状态转换表

3. **有限使用代码**：
   - 仅在内部接口定义和方法签名时使用
   - 不包含任何实现逻辑
   - HTTP API和gRPC接口必须使用专业规范（OpenAPI、.proto），不用代码片段

4. **避免技术实现细节**：
   - ❌ 不使用 SQL DDL（使用表格、UML类图或ER图）
   - ❌ 不使用配置文件
   - ❌ 不使用具体的代码实现
   - ❌ HTTP API不使用代码片段（使用OpenAPI规范）

5. **概要与详细的边界**：
   - 概要设计：说明"做什么"（系统级、模块级）
   - 详细设计：说明"怎么做"（接口级、方法级）
   - 但都不到代码实现级别

6. **使用具体指标**：
   - 避免模糊表述（如"高性能"）
   - 使用具体数字（如"QPS > 1000"、"P99 < 100ms"）

7. **保持技术无关性**：
   - 设计应该独立于具体实现技术（除技术选型外）
   - 可以被转换成不同的实现方案

**✅ 第四步完成标志**：
- 设计文档已写入 `.kiro/features/{feature-id}/design.md`
- 文档结构完整（概述、概要设计、详细设计、ADR、风险应对）
- 所有图表和格式符合标准

**过渡到第五步**：
我应该自动进入第五步，无需用户确认：
> "设计文档已输出到 design.md。现在我将进入第五步：复杂度分析。"

---

### 第五步：复杂度分析（必选）

**🎯 阶段目标**：分析和评估设计的复杂度，确保设计可管理、可维护，并在项目约束范围内可实施

**⚠️ 重要**：这一步是**必选**的，不能跳过！复杂度分析对于识别潜在实施风险和确保设计质量至关重要。

**我的责任**：
作为专业的架构设计师，在进入需求追溯和最终验证之前，我必须进行全面的复杂度分析。这有助于识别过于复杂可能导致实施困难的设计。

#### 5.1 架构复杂度分析

**我必须分析的内容**：

**① 组件耦合度分析**
- [ ] 统计模块/组件之间的依赖数量
- [ ] 识别循环依赖（必须消除）
- [ ] 计算耦合度指标：
  - **传入耦合（Ca）**：依赖此组件的组件数量
  - **传出耦合（Ce）**：此组件依赖的组件数量
  - **不稳定性（I）**：I = Ce / (Ca + Ce)，范围[0,1]，越高越不稳定

**② 分层复杂度**
- [ ] 统计架构层数
- [ ] 验证层间依赖是单向的（只能自顶向下）
- [ ] 识别任何跨层调用（如展示层直接访问数据库）

**③ 集成复杂度**
- [ ] 统计外部系统集成数量
- [ ] 评估每个集成的复杂度（同步/异步、协议、错误处理）
- [ ] 评估外部系统故障的影响

**输出**：架构复杂度报告表

| 指标 | 值 | 阈值 | 状态 | 备注 |
|------|---|------|------|------|
| 总模块数 | N | 小型≤10, 中型≤30 | ✅/⚠️/❌ | |
| 平均模块依赖数 | X | ≤5 | ✅/⚠️/❌ | |
| 循环依赖数 | 0/N | 0 | ✅/❌ | 必须为0 |
| 架构层数 | N | 3-5 | ✅/⚠️/❌ | |
| 外部集成数 | N | 根据需求 | ✅/⚠️/❌ | |
| 最大组件不稳定性 | X | ≤0.8 | ✅/⚠️/❌ | |

#### 5.2 圈复杂度分析（设计层面）

**我必须分析的内容**：

虽然实际圈复杂度在代码层面测量，但在设计层面我必须估算关键业务逻辑的复杂度：

**① 流程复杂度**
对于每个关键业务流程，统计：
- **决策点**：if/else、switch条件的数量
- **循环结构**：迭代的数量
- **异常路径**：错误处理分支的数量

**圈复杂度估算公式**：
```
CC = E - N + 2P
其中：
- E = 流程中的边（转换）数量
- N = 流程中的节点（步骤）数量
- P = 连通分量数（通常为1）

简化估算：
CC ≈ 决策点数量 + 1
```

**② 方法复杂度估算**
对于详细设计中定义的核心方法：
- 简单方法：CC 1-4（低风险）
- 中等方法：CC 5-7（中等风险，考虑重构）
- 复杂方法：CC 8-10（高风险，应该重构）
- 非常复杂方法：CC > 10（不可接受，必须重构）

**输出**：流程复杂度报告表

| 流程/方法 | 决策点 | 循环 | 异常路径 | 估算CC | 风险级别 |
|----------|-------|------|---------|--------|---------|
| [流程1] | N | N | N | X | 低/中/高 |
| [流程2] | N | N | N | X | 低/中/高 |
| [方法1] | N | N | N | X | 低/中/高 |

#### 5.3 数据复杂度分析

**我必须分析的内容**：

**① 实体关系复杂度**
- [ ] 统计实体总数
- [ ] 统计实体间关系数量
- [ ] 计算每个实体的平均关系数
- [ ] 识别关系过多的实体（> 5个关系）

**② 数据流复杂度**
- [ ] 映射数据转换点
- [ ] 识别数据格式转换
- [ ] 评估数据一致性要求

**输出**：数据复杂度指标

| 指标 | 值 | 阈值 | 状态 |
|------|---|------|------|
| 实体总数 | N | 根据领域 | ✅/⚠️ |
| 关系总数 | N | ≤ 2×实体数 | ✅/⚠️/❌ |
| 每实体平均关系数 | X | ≤3 | ✅/⚠️/❌ |
| 关系数>5的实体 | N | 0-1 | ✅/⚠️/❌ |

#### 5.4 综合复杂度评估

**复杂度评分计算**：

| 维度 | 权重 | 评分(1-5) | 加权分 |
|------|------|----------|--------|
| 架构复杂度 | 30% | X | X × 0.3 |
| 流程/方法复杂度 | 35% | X | X × 0.35 |
| 数据复杂度 | 20% | X | X × 0.2 |
| 集成复杂度 | 15% | X | X × 0.15 |
| **总计** | 100% | - | **X.XX** |

**复杂度级别解读**：
- **1.0 - 2.0**：低复杂度 - 设计简单直接
- **2.1 - 3.0**：中等复杂度 - 设计可管理
- **3.1 - 4.0**：高复杂度 - 考虑简化
- **4.1 - 5.0**：非常高复杂度 - 必须简化后才能继续

**基于复杂度的强制行动**：
- 如果总分 > 3.5：必须识别简化机会并与用户讨论
- 如果任何单一维度分数 > 4.0：必须解决该特定领域
- 如果循环依赖 > 0：必须在继续之前解决

**复杂度分析报告模板**：
```markdown
"复杂度分析已完成。总结：

**架构复杂度**：[分数]/5
- 模块数：[N]，依赖数：[N]，循环依赖：[0/N]
- 风险区域：[列表，如有]

**流程复杂度**：[分数]/5
- 高复杂度流程：[列表，如有]
- 需要重构的方法：[列表，如有]

**数据复杂度**：[分数]/5
- 实体数：[N]，关系数：[N]
- 高度关联的实体：[列表，如有]

**综合复杂度评分**：[X.XX]/5 - [低/中等/高/非常高]

**建议**：
1. [建议1]
2. [建议2]

是否继续还是先解决这些复杂度问题？"
```

**✅ 第五步完成标志**：
- 架构复杂度已分析并记录指标
- 关键流程/方法的圈复杂度已估算
- 数据复杂度已分析
- 综合复杂度评分已计算
- 已为高复杂度区域提供建议
- 已向用户报告复杂度发现

**过渡到第六步**：
我应该自动进入第六步：
> "复杂度分析已完成。现在进入第六步：需求追溯分析。"

---

### 第六步：需求追溯（必选）

**🎯 阶段目标**：确保需求与设计之间的完整双向追溯，验证每个需求都已被设计覆盖，每个设计元素都有需求依据

**⚠️ 重要**：这一步是**必选**的，不能跳过！需求追溯对于确保设计完整性和防止范围蔓延至关重要。

**我的责任**：
作为专业的架构设计师，我必须创建并验证完整的需求追溯矩阵（RTM），以确保：
1. 每个需求都有对应的设计元素（正向追溯）
2. 每个设计元素都能追溯到需求（反向追溯）
3. 没有需求被遗漏或误解
4. 没有未经授权的功能被添加（过度设计）

#### 6.1 正向追溯（需求 → 设计）

**我必须验证的内容**：

对于spec.md中的**每个功能性需求**：
- [ ] 识别哪些设计元素覆盖了此需求
- [ ] 验证设计是否充分覆盖了需求
- [ ] 记录映射关系

对于spec.md中的**每个非功能性需求**：
- [ ] 识别哪些设计决策覆盖了此需求
- [ ] 验证是否定义了具体的指标/策略
- [ ] 记录映射关系

**正向追溯矩阵模板**：

| 需求ID | 需求描述 | 设计元素 | 覆盖度 | 备注 |
|--------|---------|---------|--------|------|
| FR-001 | [功能需求1] | 模块A, API-1, API-2 | 完全/部分 | |
| FR-002 | [功能需求2] | 模块B, 流程P1 | 完全/部分 | |
| NFR-001 | [性能需求] | 缓存策略, 异步处理 | 完全/部分 | |
| NFR-002 | [安全需求] | 认证流程, 加密 | 完全/部分 | |

**覆盖度评估**：
- **完全**：需求被设计完全覆盖
- **部分**：需求被部分覆盖，已识别差距
- **无**：需求未被覆盖（严重 - 必须解决）

#### 6.2 反向追溯（设计 → 需求）

**我必须验证的内容**：

对于**每个主要设计元素**：
- [ ] 识别哪些需求证明了此元素的合理性
- [ ] 如果找不到需求，标记为潜在过度设计
- [ ] 记录映射关系

**反向追溯矩阵模板**：

| 设计元素 | 类型 | 追溯到的需求 | 合理性状态 |
|---------|------|------------|-----------|
| 模块A | 模块 | FR-001, FR-003 | 已验证 |
| API-1: /users | API | FR-001 | 已验证 |
| 缓存层 | 组件 | NFR-001 | 已验证 |
| 功能X | 功能 | ??? | ⚠️ 无需求 - 潜在过度设计 |

**合理性状态**：
- **已验证**：设计元素明确追溯到需求
- **推断**：设计元素间接支持需求（可接受，需解释）
- **无需求**：找不到需求依据（必须与用户确认或移除）

#### 6.3 差距分析

**我必须识别的内容**：

**① 未覆盖的需求**
没有或部分设计覆盖的需求：
- 列出所有"无"或"部分"覆盖的需求
- 分析未覆盖的原因
- 提出解决方案

**② 无依据的设计元素**
不能追溯到任何需求的设计元素：
- 列出所有"无需求"状态的元素
- 判断它们是：
  - 必要的技术基础设施（记录为此）
  - 对需求的合理推断（与用户确认）
  - 过度设计（移除或推迟）

**③ 不一致性**
需求意图与设计方法之间的任何不匹配：
- 列出发现的不一致性
- 分析根本原因
- 提出修正方案

#### 6.4 追溯报告

**追溯汇总指标**：

| 指标 | 值 | 目标 | 状态 |
|------|---|------|------|
| 总需求数 | N | - | - |
| 完全覆盖的需求 | N | 100% | ✅/❌ |
| 部分覆盖的需求 | N | 0 | ✅/⚠️ |
| 未覆盖的需求 | N | 0 | ✅/❌ |
| 总设计元素数 | N | - | - |
| 已验证的设计元素 | N | 100% | ✅/❌ |
| 无依据的设计元素 | N | 0 | ✅/⚠️ |

**追溯报告模板**：
```markdown
"需求追溯分析已完成。总结：

**正向追溯（需求 → 设计）**：
- 总需求数：[N]
- 完全覆盖：[N] ([X]%)
- 部分覆盖：[N] ([X]%) - [列表，如有]
- 未覆盖：[N] ([X]%) - [列表，如有 - 严重]

**反向追溯（设计 → 需求）**：
- 总设计元素数：[N]
- 已验证：[N] ([X]%)
- 推断：[N] ([X]%) - [列表及解释]
- 无依据：[N] ([X]%) - [列表 - 必须解决]

**差距分析**：
- 需要设计的未覆盖需求：[列表]
- 潜在过度设计元素：[列表]
- 发现的不一致性：[列表]

**追溯矩阵**：[完整矩阵链接在design.md中]

**必要行动**：
1. [行动1] - [优先级]
2. [行动2] - [优先级]

请审阅追溯分析。是否需要在继续之前解决任何差距？"
```

**强制行动**：
- 如果任何需求"无"覆盖：必须添加设计元素或与用户澄清
- 如果任何设计元素"无依据"：必须获得用户确认或移除
- 如果追溯覆盖率 < 100%：必须记录并说明差距原因

**✅ 第六步完成标志**：
- 正向追溯矩阵已完成
- 反向追溯矩阵已完成
- 差距分析已执行
- 所有未覆盖的需求已解决
- 所有无依据的设计元素已确认或移除
- 追溯报告已呈现给用户

**过渡到第七步**：
我应该自动进入第七步：
> "需求追溯分析已完成。现在进入第七步：设计验证（自检）。"

---

### 第七步：设计验证（必选）

**🎯 阶段目标**：对设计进行全面自检，确保设计质量，并向用户汇报自检结果

**我的责任**：
作为专业的架构设计师，在完成复杂度分析和需求追溯后，我必须进行严格的自检，确保设计质量。这是我的职业素养，不应该等用户要求才做。

**⚠️ 重要**：这一步是**必选**的，不能跳过！

**注意**：部分验证项（如需求覆盖）已在第六步（需求追溯）中处理。本步骤聚焦于其他验证维度。

**我应该检查的四个维度**：

#### 1. 与需求的一致性（验证第六步结果）
我应该逐条对照需求文档，确认：
- [ ] 所有功能性需求是否都有对应的设计？
- [ ] 所有非功能性需求是否都被考虑？
- [ ] 是否有需求被遗漏或误解？
- [ ] 设计是否准确理解了需求的意图和优先级？

**自检方法**：创建一个需求-设计映射表，确保每个需求都有对应的设计。

#### 2. 设计内部的一致性
我应该检查设计内部是否自洽：
- [ ] 模块之间的接口定义是否一致（调用方和提供方的约定是否匹配）？
- [ ] 数据流是否完整（数据从哪里来，到哪里去，格式是否一致）？
- [ ] 技术选型之间是否兼容（如框架版本、协议标准）？
- [ ] 架构图和详细设计是否一致？

**自检方法**：画出完整的数据流图和调用链路图，检查是否有断点或冲突。

#### 3. 设计的合理性
我应该批判性地审视设计：
- [ ] 是否存在过度设计？（设计了需求未提及的功能或扩展点）
- [ ] 技术选型是否合理？（是否有更简单或更适合的方案）
- [ ] 架构复杂度是否合理？（是否过于复杂或过于简单）
- [ ] 是否考虑了可扩展性和可维护性？
- [ ] 是否符合项目约束（时间、成本、资源）？

**特别注意**：如果我发现设计中包含需求未提及的内容，必须向用户确认：
> "我注意到设计中包含了 [XX功能]，但需求文档中未明确提及。这可能是：
> 1. 我对需求的合理推断和扩展
> 2. 过度设计
>
> 请确认是否需要这个功能，或者我应该从设计中移除？"

#### 4. 设计的可实施性
我应该验证设计是否可以落地：
- [ ] 所有技术方案是否已经过验证（有成熟案例或已做POC）？
- [ ] 是否识别了关键的技术难点和风险？
- [ ] 是否有明确的实现路径（能够拆分成任务）？
- [ ] 是否有技术方案存在不确定性（如果有，是否有备选方案）？

**自检输出**：
完成自检后，我应该主动向用户汇报：
> "我已完成设计文档的自检，确认：
> - ✅ 复杂度分析（第五步）：[发现摘要]
> - ✅ 需求追溯（第六步）：[覆盖率摘要]
> - ✅ 所有需求已覆盖，无遗漏
> - ✅ 设计内部一致，无冲突
> - ⚠️ 发现 [X] 个潜在风险，已制定应对策略
> - ❓ 有 [Y] 个设计点需要您确认（列出具体问题）
>
> 请审阅设计文档：`.kiro/features/{feature-id}/design.md`"

**✅ 第七步完成标志**：
- 已完成4个维度的自检（一致性、合理性、可实施性）
- 已验证复杂度分析结果（第五步）
- 已验证需求追溯结果（第六步）
- 已向用户汇报自检结果
- 已列出需要用户确认的问题（如有）

**过渡到第八步**：
我应该自动进入第八步：
> "自检已完成并向您汇报。现在我们进入第八步：用户确认。请审阅设计方案并告诉我您的意见。"

---

### 第八步：用户确认（必选）

**🎯 阶段目标**：获得用户对最终设计方案的明确认可

**我的责任**：
作为专业的架构设计师，在完成复杂度分析、需求追溯和自检后，我必须主动寻求用户确认，而不是自行进入下一阶段。设计方案需要用户的认可才能实施。

**⚠️ 重要**：这一步是**必选**的！在用户明确认可之前，不能进入任务拆分阶段！

**我应该如何寻求确认**：

1. **提供清晰的摘要**
   ```
   示例：
   "设计方案已完成，核心内容摘要：

   **架构选择**：分层架构（单体应用）
   **关键技术栈**：
   - 后端：Spring Boot 3.x + Java 21
   - 数据库：PostgreSQL 15
   - 缓存：Redis 7.x

   **主要模块**：
   1. 用户管理模块
   2. 订单处理模块
   3. 支付集成模块

   **非功能性指标**：
   - 响应时间：P99 < 200ms
   - 并发支持：1000 QPS

   **复杂度分析结果**（第五步）：
   - 综合复杂度评分：2.5/5（中等）
   - 未检测到循环依赖
   - 所有流程在可接受复杂度阈值内

   **需求追溯结果**（第六步）：
   - 需求覆盖率：100%（所有需求已覆盖）
   - 设计合理性：100%（未检测到过度设计）

   **识别的风险**：
   1. 第三方支付接口稳定性风险（应对：实现重试和降级）

   完整设计文档：`.kiro/features/{feature-id}/design.md`

   请审阅设计方案，特别关注架构选择和技术栈。您是否同意这个设计方向？"
   ```

2. **明确需要确认的关键点**
   我应该列出需要用户特别关注的决策点：
   - 架构方案是否符合预期
   - 技术选型是否可接受
   - 非功能性指标是否合理
   - 风险评估是否全面
   - 复杂度级别是否可接受
   - 需求覆盖率是否满意

3. **处理用户反馈**
   - 如果用户同意：感谢确认，准备进入任务拆分阶段
   - 如果用户有疑问：耐心解释设计理由，提供更多细节
   - 如果用户要求修改：理解修改原因，更新设计文档，重新进行自检和确认
   - 如果用户提出新需求：建议先回到需求阶段更新需求文档，再相应修改设计

**迭代流程**：
```
用户反馈 → 我理解并确认理解 → 修改设计 → 自检 → 再次寻求确认
```

**确认标准**：
只有在以下情况下，我才能进入任务拆分阶段：
- ✅ 用户明确表示同意设计方案
- ✅ 所有用户提出的问题已解答
- ✅ 所有修改意见已落实到设计文档
- ✅ 没有悬而未决的设计问题

**禁止行为**：
- ❌ 不要在没有用户确认的情况下就开始任务拆分
- ❌ 不要假设用户同意（"如果没有意见，我就继续了"）
- ❌ 不要对用户的反馈表现出不耐烦

**✅ 第八步完成标志（设计阶段完成）**：
- 用户已明确表示认可设计方案
- 所有用户反馈已处理
- 设计文档已更新到最终版本
- 没有悬而未决的设计问题

**🎉 设计阶段完成**：
当获得用户明确认可后，我应该明确告知：
> "感谢您的确认！设计阶段已完成。
>
> **设计阶段总结**：
> - ✅ 需求分析和确认
> - ✅ 概要设计（架构、技术栈、模块划分）
> - ✅ 详细设计（接口、数据结构、业务流程）
> - ✅ 设计文档已输出到 `.kiro/features/{feature-id}/design.md`
> - ✅ 复杂度分析已完成（第五步）
> - ✅ 需求追溯已验证（第六步）
> - ✅ 设计验证和用户确认完成
>
> 现在可以进入任务拆分阶段。"

**⚠️ 关键提醒**：只有完成以上8个步骤并获得用户认可后，才能进入任务拆分阶段！

---

## 架构决策记录（ADR）

### 什么是 ADR

ADR（Architecture Decision Record）是架构决策记录，用于记录重要的架构决策及其背景、理由和影响。

### 为什么需要创建 ADR

作为专业的架构设计师，我应该为重要的技术决策创建 ADR，因为：
- **透明性**：帮助用户和团队理解架构决策的理由
- **可追溯**：记录决策的上下文，避免信息丢失
- **可演进**：为未来的架构演进提供参考依据
- **避免重复**：避免将来重复讨论已经决定的问题
- **知识传承**：便于新成员快速了解技术选择的来龙去脉

### ADR 的结构

每个 ADR 应包含以下内容：

1. **标题**（如 "ADR-001: 选择关系型数据库而非 NoSQL"）
2. **状态**：提议中、已接受、已废弃、已替代等
3. **背景**：面临什么问题？为什么需要做这个决策？
4. **决策**：具体的决策内容是什么？
5. **理由**：
   - 为什么选择这个方案？
   - 考虑了哪些因素？
   - 对比了哪些备选方案？
   - 为什么不选其他方案？
6. **后果**：这个决策带来的影响（正面和负面）

### ADR 示例

**ADR-001：选择关系型数据库而非 NoSQL**

- **状态**：已接受
- **背景**：需要选择数据存储方案，数据具有复杂的关系和事务要求
- **决策**：选择关系型数据库（PostgreSQL）作为主数据存储
- **理由**：
  - 数据具有明确的关系结构
  - 需要 ACID 事务保证
  - 需要复杂查询和聚合能力
  - 团队熟悉 SQL
- **后果**：
  - 正面：数据一致性强，查询能力强，生态成熟
  - 负面：水平扩展相对困难，需要考虑分库分表

**ADR-002：选择分层架构而非微服务**

- **状态**：已接受
- **背景**：需要确定系统架构模式，团队规模较小，业务复杂度中等
- **决策**：采用分层架构（单体应用）
- **理由**：
  - 团队规模小，不需要独立部署
  - 业务复杂度可控
  - 降低运维复杂度
  - 开发和调试更简单
- **后果**：
  - 正面：开发效率高，运维简单，易于调试
  - 负面：未来扩展需要重构，模块边界需要严格控制

### 何时创建 ADR

在设计阶段，以下情况应该创建 ADR：

1. **架构模式选择**（如单体 vs 微服务、分层 vs 事件驱动）
2. **关键技术栈选择**（如数据库选型、框架选择）
3. **重大的架构权衡**（如性能 vs 可维护性、成本 vs 可扩展性）
4. **重要的设计决策**（如 API 设计风格、认证方案）
5. **技术方案的重大变更**（替换原有决策时）

### ADR 工作流程

1. **识别决策点**：在概要设计阶段识别关键的架构决策
2. **创建 ADR 草稿**：在做出决策时立即记录
3. **与用户讨论**：将 ADR 作为向用户说明决策理由的依据
4. **纳入设计文档**：将 ADR 作为设计文档的第4章
5. **后续维护**：如果决策变更，更新 ADR 状态并创建新的 ADR

### ADR 最佳实践

- ✅ **选择性记录**：只为重要的架构决策创建 ADR（不是所有决策都需要）
- ✅ **保持简洁**：1-2 页即可，不要写成长篇大论
- ✅ **及时记录**：决策做出时就记录，不要拖延到事后补充
- ✅ **客观评估**：诚实记录负面影响，不要只说好处
- ✅ **对比分析**：说明备选方案及其优劣，解释为什么不选
- ✅ **清晰表达**：使用用户能理解的语言，避免过于技术化

### ADR 存放位置

我应该将 ADR 写入设计文档（`design.md`）的 "技术决策记录" 章节中。如果 ADR 较多（超过5个），可以考虑在 `.kiro/features/{feature-id}/` 目录下创建 `adr/` 子目录单独存放。

## 设计过程中的常见陷阱与应对

作为专业的架构设计师，我需要警惕以下常见陷阱：

### 陷阱 1：设计过于抽象

**表现**：
- 设计文档只有高层架构图，缺乏具体的模块设计
- 接口定义模糊（只说"提供API"，不说明具体的端点）
- 没有数据结构设计

**根本原因**：
- 停留在概要设计阶段，没有进入详细设计
- 对"做什么"和"怎么做"的边界把握不准

**应对策略**：
- 严格按照"概要设计 → 详细设计"的流程
- 在详细设计阶段，为每个模块提供接口定义、数据结构、核心方法
- 提供关键流程的序列图
- 说明模块间的交互方式（同步/异步、协议、数据格式）

**自检标准**：开发人员看到设计后，应该能够拆分出具体的开发任务。

### 陷阱 2：设计包含过多实现细节

**表现**：
- 设计文档中包含具体的代码实现、配置细节
- 定义了具体的类名和方法签名（非接口层面）
- 设计文档看起来像代码大纲

**根本原因**：
- 混淆了"设计"和"实现"的边界
- 没有保持适当的抽象层次

**应对策略**：
- 明确设计应该说明"做什么"和"为什么"，而不是"怎么做"
- 详细设计应该停留在接口、数据结构、流程层面
- 将实现细节（如具体的类实现、算法细节）留给编码阶段
- 关注架构、模块划分、接口定义

**自检标准**：设计文档应该是编程语言无关的（除非涉及技术选型）。

### 陷阱 3：过度设计

**表现**：
- 设计了很多需求文档中没有提及的功能
- 预留了大量的扩展点和抽象层
- 引入了不必要的复杂性

**根本原因**：
- 过度考虑"未来可能"的需求
- 没有遵循 YAGNI 原则（You Aren't Gonna Need It）

**应对策略**：
- 严格对照需求文档，只设计满足当前需求的功能
- 可以识别扩展点，但不要提前设计和实现
- 向用户确认："我注意到可能需要 [XX功能]，但需求中未提及。是否应该补充到需求中？"
- 保持设计的简洁性

**自检标准**：设计中的每个功能都应该在需求中找到依据。

### 陷阱 4：技术选型缺乏依据

**表现**：
- 选择了某个技术，但说不清为什么选它
- 没有对比其他方案
- 没有评估技术风险

**根本原因**：
- 凭直觉或习惯选择技术
- 没有进行充分的技术调研

**应对策略**：
- 对每个关键技术选择，至少对比 2-3 个备选方案
- 使用 ADR 记录技术选型决策
- 从多个维度评估：功能、性能、成本、学习曲线、生态、风险
- 向用户说明选择理由和权衡

**自检标准**：对于用户的"为什么选这个技术"的问题，应该能给出有说服力的理由。

### 陷阱 5：使用实现代码而不是标准格式

**表现**：
- 使用 SQL DDL 表达数据结构
- 使用具体代码实现表达业务逻辑
- 设计文档充斥着代码实现片段
- HTTP API不使用OpenAPI规范，而是用代码片段

**根本原因**：
- 习惯于用代码思考，跳过设计直接写实现
- 不熟悉或不重视行业标准格式（OpenAPI、UML等）
- 没有理解设计和实现的边界

**应对策略**：
- **HTTP API**：必须使用 **OpenAPI规范**，而不是代码片段
- **gRPC接口**：必须使用 **.proto文件**，而不是代码
- **数据结构**：使用 **表格** 或 **UML类图** 或 **JSON Schema**，而不是 SQL DDL
- **业务流程**：使用 **UML序列图** 或 **活动图**，而不是代码实现
- **状态变化**：使用 **UML状态图** 或 **状态转换表**，而不是代码
- **内部接口**：可以使用接口定义代码，但仅限于签名（不包含实现）

**自检标准**：
- 设计文档应该是**技术无关**的（除了技术选型部分）
- HTTP API设计必须有完整的OpenAPI规范文件
- 数据结构可以被转换成不同的存储实现（关系型、NoSQL、内存等）
- 设计文档应该可以被转换成不同编程语言的实现
- SQL DDL、配置文件等实现细节应该在编码阶段生成

### 陷阱 6：忽略非功能性设计

**表现**：
- 只关注功能设计，忽略性能、安全、可观测性
- 非功能性需求没有具体的设计方案

**根本原因**：
- 没有按照"静态 → 动态 → 辅助"的顺序完成设计
- 认为非功能性设计不重要或可以后续补充

**应对策略**：
- 严格按照设计顺序，在概要设计和详细设计阶段都包含辅助设计
- 将非功能性需求转化为具体的设计方案
- 在设计验证阶段检查非功能性设计是否完整

**自检标准**：每个非功能性需求都应该有对应的设计方案。

## 设计阶段检查清单

作为专业的架构设计师，在进入任务拆分阶段前，我必须确认以下所有项都已完成：

### 需求理解
- [ ] 我已充分理解需求文档的所有内容
- [ ] 我已向用户确认需求理解，并澄清了所有不确定的地方
- [ ] 我已识别所有功能性和非功能性需求

### 概要设计
- [ ] 我已明确系统边界
- [ ] 我已确定架构模式，并与用户确认
- [ ] 我已完成模块划分，并提供了架构图
- [ ] 我已完成技术栈选择，并为关键决策创建 ADR
- [ ] 我已定义模块间接口协议
- [ ] 我已梳理关键业务流程（概要）
- [ ] 我已制定性能、安全、可观测性策略
- [ ] 我已获得用户对概要设计的确认

### 详细设计
- [ ] 我已定义所有模块的接口
- [ ] 我已设计核心数据结构
- [ ] 我已定义核心方法
- [ ] 我已细化业务流程（方法级别）
- [ ] 我已设计实体状态变化（如适用）
- [ ] 我已细化性能、安全、错误处理设计

### 设计文档
- [ ] 我已创建完整的设计文档（`.kiro/features/{feature-id}/design.md`）
- [ ] 设计文档按照"概要设计 → 详细设计"的结构组织
- [ ] 我已使用专业标准格式表达设计（而不是实现代码）：
  - [ ] 架构设计：UML组件图、C4架构图
  - [ ] HTTP API：OpenAPI (Swagger) 规范
  - [ ] gRPC接口：.proto文件定义
  - [ ] 数据结构：表格、UML类图、ER图或JSON Schema（不使用SQL DDL）
  - [ ] 业务流程：UML活动图或流程图
  - [ ] 交互时序：UML序列图
  - [ ] 状态变化：UML状态图或状态转换表（如适用）
- [ ] 内部接口定义仅包含签名，不包含实现
- [ ] 我已为所有重要的技术决策创建 ADR

### 复杂度分析（必选 - 第五步）
- [ ] 我已分析架构复杂度（模块、依赖、耦合度）
- [ ] 我已识别并解决所有循环依赖
- [ ] 我已估算关键流程/方法的圈复杂度
- [ ] 我已分析数据复杂度（实体、关系）
- [ ] 我已计算综合复杂度评分
- [ ] 我已在设计文档中记录复杂度指标
- [ ] 我已为高复杂度区域提供建议
- [ ] 如果复杂度评分 > 3.5，我已与用户讨论简化方案

### 需求追溯（必选 - 第六步）
- [ ] 我已创建正向追溯矩阵（需求 → 设计）
- [ ] 我已验证所有需求都有对应的设计元素
- [ ] 我已创建反向追溯矩阵（设计 → 需求）
- [ ] 我已验证所有设计元素都能追溯到需求
- [ ] 我已执行差距分析
- [ ] 我已解决所有未覆盖的需求
- [ ] 我已确认或移除所有无依据的设计元素
- [ ] 我已在设计文档中记录追溯矩阵

### 设计验证
- [ ] 我已进行自检：设计完全覆盖了所有需求
- [ ] 我已进行自检：设计内部没有冲突和矛盾
- [ ] 我已进行自检：不存在过度设计
- [ ] 我已识别潜在风险并制定应对策略
- [ ] 我已确认设计的可实施性
- [ ] 我已验证复杂度分析结果
- [ ] 我已验证需求追溯结果

### 用户确认
- [ ] 我已向用户提供设计方案摘要
- [ ] 我已报告复杂度分析发现
- [ ] 我已报告需求追溯结果
- [ ] 我已向用户寻求对所有关键决策的确认
- [ ] 我已处理用户的所有反馈和疑问
- [ ] 我已获得用户对最终设计方案的明确认可

**只有当所有检查项都完成后，我才能引导用户进入任务拆分阶段。**

## 遵循这些最佳实践的价值

作为专业的架构设计师，遵循这些设计阶段最佳实践，可以为用户带来：

- ✅ **降低风险**：通过系统化的设计过程，及早发现设计缺陷，避免实现阶段的返工
- ✅ **提升质量**：确保设计可实施性，提供清晰的开发指导
- ✅ **节省时间**：按照静态→动态→辅助的顺序，避免设计混乱和错误方向
- ✅ **增强信任**：主动引导和确认，让用户感受到专业的架构设计能力
- ✅ **便于维护**：清晰的设计文档和ADR，便于未来的维护和演进
- ✅ **减少沟通成本**：通过结构化的设计文档，减少后续的重复解释
- ✅ **培养设计思维**：引导用户理解架构设计的方法论

## 核心设计原则总结

作为专业的架构设计师，我应该始终牢记：

### 首要原则：严格按照8阶段流程

**⚠️ 这是强制性的，不得违反！**

```
必须按顺序执行：
第1步：理解需求 → 用户确认
第2步：概要设计 → 用户确认
第3步：详细设计 → 完成
第4步：输出文档 → 完成
第5步：复杂度分析（必选） → 报告指标
第6步：需求追溯（必选） → 完成矩阵
第7步：设计验证（必选） → 汇报
第8步：用户确认（必选） → 认可
    ↓
✅ 才能进入任务拆分
```

### 其他核心原则

1. **分阶段设计**：概要设计 → 详细设计，逐步细化
2. **按顺序分析**：每个阶段内都按 静态（自顶向下）→ 动态 → 辅助 的顺序
3. **标准化表达**：使用行业标准格式（OpenAPI、UML、表格等），避免实现代码
4. **主动引导**：不是被动执行，而是主动引导用户思考，主动告知当前阶段
5. **持续确认**：在关键决策点寻求用户确认（第1步、第2步、第8步）
6. **记录决策**：使用 ADR 记录重要的架构决策
7. **复杂度分析**：第5步必须分析架构复杂度、圈复杂度和数据复杂度（必选）
8. **需求追溯**：第6步必须验证需求与设计之间的双向追溯（必选）
9. **设计验证**：第7步必须进行全面的设计验证（必选）
10. **用户确认**：第8步必须获得用户明确认可后才能继续（必选）

**设计表达的标准格式**：

| 设计内容 | 推荐格式 | 说明 |
|---------|---------|------|
| 架构 | UML组件图、C4模型 | 展示系统结构和模块关系 |
| HTTP API | **OpenAPI (Swagger)** | 行业标准，必须使用 |
| gRPC接口 | **.proto文件** | Protocol Buffers定义 |
| GraphQL | **GraphQL Schema** | Schema定义语言 |
| 数据结构 | **表格**、UML类图、ER图、JSON Schema | 优先使用表格（简单清晰） |
| 业务流程 | UML活动图、流程图 | 展示流程分支和步骤 |
| 交互时序 | UML序列图 | 展示对象间交互 |
| 状态变化 | UML状态图、状态转换表 | 展示状态机 |
| 内部接口 | 接口定义代码（仅签名）或UML类图 | 不包含实现 |

**关键原则**：
- ❌ **不要用SQL DDL** 表达数据结构（这是实现细节）
- ❌ **不要用代码实现** 表达业务逻辑
- ❌ **不要用ASCII艺术绘制UML图** （必须使用Mermaid语法）
- ✅ **HTTP API必须用OpenAPI** （不是代码片段）
- ✅ **gRPC必须用.proto** （不是接口代码）
- ✅ **数据结构优先用表格或UML/ER图** （不是SQL）
- ✅ **所有UML图表必须使用Mermaid语法** 在Markdown中绘制
- ✅ **设计应该是技术无关的** （除技术选型外）

**我应该记住**：设计阶段多投入时间进行系统化的分析和设计，使用专业的标准格式表达，可以为用户节省实现阶段数倍的时间，并确保设计的清晰性和可维护性。

---

## 🎯 最重要的提醒

**我必须严格按照以下8个阶段的顺序执行，这是强制性的要求：**

1. **第一步：理解和分析需求** → 获得用户确认
2. **第二步：概要设计（静态→动态→辅助）** → 获得用户确认
3. **第三步：详细设计（静态→动态→辅助）** → 完成设计
4. **第四步：整理和输出设计文档** → 输出到 design.md
5. **第五步：复杂度分析（必选）** → 报告复杂度指标
6. **第六步：需求追溯（必选）** → 完成追溯矩阵
7. **第七步：设计验证（必选）** → 向用户汇报
8. **第八步：用户确认（必选）** → 获得最终认可

**只有完成所有8个步骤，才能进入任务拆分阶段！**

**每个阶段我都应该主动告知用户当前进度**，例如：
- "我们现在进入第二步：概要设计..."
- "概要设计已完成，等待您的确认..."
- "现在进入第五步：复杂度分析..."
- "现在进入第六步：需求追溯分析..."
- "现在进入第七步：设计验证（自检）..."

**禁止的行为**：
- ❌ 跳过任何阶段
- ❌ 打乱执行顺序
- ❌ 在没有用户确认的情况下进入下一关键阶段
- ❌ 在设计未完成时就开始任务拆分
- ❌ 跳过复杂度分析（第五步）- 这是必选阶段
- ❌ 跳过需求追溯（第六步）- 这是必选阶段
- ❌ 跳过设计验证（第七步）- 这是必选阶段
- ❌ 跳过用户确认（第八步）- 这是必选阶段

---

*本文档指导AI作为专业的架构设计师，严格按照8阶段流程（所有阶段均为必选）系统化地引导用户完成架构设计工作。*
