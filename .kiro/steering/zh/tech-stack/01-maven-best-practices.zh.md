---
inclusion: manual
---

# Maven 最佳实践

## 快速参考

| 规则 | 要求 | 优先级 | 说明 |
|------|------|--------|------|
| 渐进式模块声明 | MUST 只声明已创建的模块 | P0 | 避免构建错误 |
| 依赖变更确认 | MUST 获得用户明确同意 | P0 | 保持架构一致性 |
| 任务完成后验证构建 | MUST 执行 `mvn clean compile` | P0 | 确保项目可构建 |
| 版本管理统一 | MUST 使用 dependencyManagement | P1 | 避免版本冲突 |
| 模块同步更新 | MUST 创建模块后立即更新父POM | P0 | 保持配置同步 |

## 关键规则 (NON-NEGOTIABLE)

| 规则 | 描述 | 正确示例 | 错误示例 |
|------|------|----------|----------|
| **只声明已创建模块** | 父POM中只包含实际存在的模块目录 | `<module>domain</module>` (domain已创建) | `<module>future-module</module>` (未创建) |
| **依赖变更必须确认** | 新增/修改依赖前获得用户明确同意 | 先询问: "需要引入xxx依赖，是否同意?" | 直接在POM中添加新依赖 |
| **任务完成验证构建** | 每个任务完成后运行构建验证 | `mvn clean compile` → 成功 | 完成任务但未验证构建 |
| **版本统一管理** | 父POM的dependencyManagement管理版本 | 父POM定义版本，子模块不指定 | 子模块各自指定不同版本 |
| **渐进式添加** | 先创建模块，再更新父POM | 1.创建目录 2.更新POM | 先在POM声明，后创建目录 |

## 渐进式开发原则

### 核心原则

在多模块 Maven 项目中，采用渐进式开发策略，避免预先声明尚未创建的模块。

**基本原则**：
- 只在父 POM 中声明已创建的模块
- 创建新模块时同步更新父 POM
- 对于多层级结构，同样遵循此原则

### 为什么重要

- **避免构建错误**：预先声明不存在的模块会导致构建失败
- **保持配置与实际结构同步**：确保 POM 配置反映真实的项目结构
- **支持增量开发**：每个阶段项目都处于可构建状态

### 实施步骤

1. **确认当前状态**：检查父 POM 中只包含已创建的模块
2. **创建新模块**：创建模块目录和 pom.xml
3. **更新父 POM**：在父 POM 中添加新模块的声明
4. **验证构建**：运行构建命令确保构建成功

### 多层级模块处理

对于多层级模块结构（如 application 下有 application-api 和 application-impl），同样遵循渐进式原则：
- 父模块 POM 中只声明已创建的子模块
- 创建新子模块后再更新父模块 POM

## 项目构建验证

### 关键要求

**每执行完成一个任务，都要求整个工程都可以被成功构建。**

### 为什么重要

- 项目始终处于可运行状态
- 及时发现集成问题
- 支持持续集成和持续交付
- 降低后期集成风险

### 验证方法

1. **基础构建验证**：`mvn clean compile`
2. **完整构建验证**：`mvn clean package`
3. **测试验证**：`mvn clean test`

### 构建失败处理

**常见原因**：
- 模块声明与实际结构不一致
- 依赖关系配置错误
- 版本不兼容
- 代码语法错误

**应对策略**：
- 检查父 POM 中的模块声明是否正确
- 确认依赖版本是否兼容
- 检查代码语法错误
- 查看构建日志定位具体问题

## 依赖管理

### 依赖版本管理原则

- 在父 POM 中使用 `<dependencyManagement>` 统一管理依赖版本
- 子模块引用其他模块时，不需要指定版本（由父 POM 管理）
- 保持依赖版本的一致性和可控性

### ⚠️ 依赖变更确认机制（强制要求）

**核心原则**：禁止私自改动模块之间的依赖关系，引入新的依赖时，必须与用户确认。

#### 必须确认的情况

以下情况**必须**先与用户确认，获得明确同意后才能执行：

1. **引入新的外部依赖**
   - 添加新的第三方库或框架
   - 引入新的 Spring Boot Starter
   - 添加新的工具类库

2. **修改模块间依赖关系**
   - 在模块 A 中新增对模块 B 的依赖
   - 移除模块间的现有依赖
   - 调整依赖的 scope（compile、provided、test 等）

3. **变更依赖版本**
   - 升级或降级依赖版本
   - 修改父 POM 中的版本管理

4. **引入传递性依赖**
   - 可能带来大量传递依赖的库
   - 可能与现有依赖冲突的库

#### 确认流程

**第1步：识别依赖变更需求**
```
我注意到需要 [具体说明需要什么依赖]，原因是 [说明原因]。
```

**第2步：说明依赖详情**
```
依赖信息：
- GroupId: [groupId]
- ArtifactId: [artifactId]
- Version: [version]
- Scope: [compile/provided/test]

影响范围：
- 影响模块：[列出受影响的模块]
- 传递依赖：[是否会引入大量传递依赖]
- 潜在冲突：[是否可能与现有依赖冲突]
```

**第3步：等待用户确认**
```
请确认是否可以引入此依赖？
```

**第4步：执行变更**
- 只有在用户明确同意后，才能修改 POM 文件
- 修改后立即验证构建是否成功
- 如有问题，及时向用户报告

#### 禁止的行为

- ❌ 不要在没有用户确认的情况下引入新依赖
- ❌ 不要私自修改模块间的依赖关系
- ❌ 不要假设用户会同意依赖变更
- ❌ 不要在任务执行过程中"顺便"添加依赖

#### 例外情况

以下情况可以不需要确认（但仍需在任务完成后告知用户）：
- 设计文档中已明确指定的依赖
- 任务描述中已明确要求的依赖
- 项目已有的依赖（不是新增）

### 为什么需要确认机制

1. **架构一致性**：避免引入与架构设计不符的依赖
2. **版本控制**：避免依赖版本冲突和不兼容
3. **安全性**：避免引入有安全漏洞的依赖
4. **许可证合规**：避免引入许可证不兼容的依赖
5. **项目可维护性**：避免依赖过多导致项目臃肿
6. **团队协作**：确保团队对依赖变更有知情权

## 常见问题

### 问题 1：模块未找到

**错误信息**：
```
[ERROR] Child module xxx of yyy does not exist
```

**原因**：父 POM 中声明了不存在的模块

**解决**：
- 检查模块目录是否存在
- 检查模块路径是否正确
- 如果模块尚未创建，从父 POM 中移除声明

### 问题 2：循环依赖

**错误信息**：
```
[ERROR] The projects in the reactor contain a cyclic reference
```

**原因**：模块间存在循环依赖

**解决**：
- 重新设计模块依赖关系
- 提取公共部分到独立模块
- 使用接口隔离依赖

### 问题 3：版本冲突

**错误信息**：
```
[WARNING] Some problems were encountered while building the effective model
```

**原因**：不同模块引入了同一依赖的不同版本

**解决**：
- 在父 POM 的 `<dependencyManagement>` 中统一版本
- 使用 `mvn dependency:tree` 查看依赖树
- 使用 `<exclusions>` 排除冲突的传递依赖

## 检查清单

在完成模块创建或修改后，确认：

- [ ] 父 POM 中的模块声明与实际目录结构一致
- [ ] 所有声明的模块都已创建
- [ ] 项目可以成功构建（`mvn clean compile`）
- [ ] 没有构建错误或警告
- [ ] 依赖关系配置正确
- [ ] 版本管理统一在父 POM 中
- [ ] **所有新增或修改的依赖都已获得用户确认**
- [ ] **依赖变更的原因和影响已向用户说明**

## 总结

Maven 多模块项目的核心原则是**渐进式开发**、**持续可构建**和**依赖变更确认**：

1. **只声明已创建的模块**
2. **创建模块时同步更新配置**
3. **每个任务完成后验证构建**
4. **保持项目始终处于健康状态**
5. **⚠️ 依赖变更必须先与用户确认**

遵循这些原则可以：
- ✅ 避免构建错误
- ✅ 支持增量开发
- ✅ 降低集成风险
- ✅ 提高开发效率
- ✅ 保持架构一致性
- ✅ 避免依赖冲突和安全风险
