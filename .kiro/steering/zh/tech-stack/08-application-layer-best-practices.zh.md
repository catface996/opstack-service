---
inclusion: manual
---

# Application 层最佳实践

本文档指导 AI 如何在 DDD 架构中正确编写 Application 层（应用服务层）代码，确保代码清晰、可维护、符合单一职责原则。

## 快速参考

| 规则 | 要求 | 优先级 |
|------|------|--------|
| 方法步骤 | MUST 主方法包含 5-10 个清晰步骤 | P0 |
| 条件判断 | NEVER 在主方法中使用 if/else | P0 |
| 异常处理 | NEVER 在主方法中使用 try/catch | P0 |
| 职责封装 | MUST 将验证/转换/日志封装到私有方法 | P0 |
| 方法长度 | MUST 主方法不超过 20 行 | P1 |

## 关键规则 (NON-NEGOTIABLE)

| 规则 | 描述 | ✅ 正确 | ❌ 错误 |
|------|------|---------|---------|
| **清晰步骤** | 主方法 5-10 步，每步一个方法调用 | `// 1. 验证\nvalidateUsername(request);` | 主方法包含 30+ 行详细逻辑 |
| **无 if/else** | 条件判断封装到私有方法 | `validateAccountNotLocked(username);` | `if (lockInfo.isPresent()) { throw... }` |
| **无 try/catch** | 异常自然传播到全局处理器 | 直接调用业务方法 | `try { service.xxx() } catch { log... }` |
| **职责分离** | 验证/转换/日志提取到私有方法 | `logRegistrationSuccess(account);` | 在主方法中写 10 行日志代码 |
| **方法命名** | 使用 validate/create/build/convertTo/log 前缀 | `validatePasswordStrength()` | `process()` 或 `handle()` |

## 核心原则

### 1. 流程编排原则

Application 层的核心职责是**编排业务流程**，而不是实现业务逻辑。

**你必须遵守**：
- ✅ 协调领域服务完成业务流程
- ✅ 处理事务边界
- ✅ 转换 DTO 和领域模型
- ❌ 不实现具体的业务规则（应在 Domain 层）
- ❌ 不直接操作数据库（应通过 Repository）
- ❌ 不包含复杂的条件判断（应封装到子方法或 Domain 层）

### 2. 方法步骤原则

每个应用服务方法应该**步骤清晰、可读性强**。

**你应该确保**：
- ✅ 方法体包含 5-10 个清晰的步骤
- ✅ 每个步骤是一个方法调用，语义明确
- ✅ 主流程中避免 if/else、try/catch 等控制结构
- ✅ 将条件判断封装到私有方法中
- ✅ 将异常处理封装到统一的位置

### 3. 职责分离原则

**你必须将不同职责分离到不同的方法中**：

| 职责 | 示例 | 应该放在 |
|------|------|---------|
| 数据验证 | 检查用户名唯一性、密码强度 | 私有验证方法 |
| 领域对象创建 | 创建 Account 实体 | 私有工厂方法 |
| 模型转换 | Account → UserInfo | 私有转换方法 |
| 审计日志 | 记录操作日志 | 私有日志方法 |
| 业务逻辑 | 密码加密、会话创建 | Domain 层服务 |

## 方法编写规范

### 规范1：主方法只包含流程编排

**你不应该做的 ❌**：
1. 在主方法中包含 if/else 条件判断
2. 编写详细的模型转换逻辑（5+ 行的属性映射）
3. 编写详细的审计日志逻辑
4. 用 try/catch 包裹业务逻辑
5. 创建对象时包含 5+ 行的属性设置
6. 编写超过 20 行的主方法

**你应该做的 ✅**：
1. 主方法包含 6-10 个清晰的编号步骤（例如：// 1. 验证，// 2. 创建，等）
2. 每个步骤是一个方法调用或简单赋值
3. 主流程中没有 if/else 语句
4. 主流程中没有 try/catch 块（异常自然传播）
5. 每个步骤的方法名具有清晰的语义
6. 主方法读起来像高层业务流程描述

**效果**：
- 主方法从 80+ 行减少到 15-20 行
- 业务流程一目了然
- 易于理解、维护和测试

### 规范2：将条件判断封装到私有方法

**封装规则**：
1. **所有 if/else 语句**必须移到私有方法中
2. **方法名必须清晰表明**正在检查的条件
3. **验证方法**失败时抛出异常（使用 `validate` 前缀）
4. **检查方法**失败时返回 boolean 或 Optional（使用 `check` 前缀）
5. **私有方法**可以包含条件逻辑，但保持单一职责

**好处**：
- 主方法保持干净和线性
- 条件逻辑可以独立测试
- 方法名自文档化了正在检查的条件

### 规范3：模型转换方法的最佳实践

**命名规范**：
- `convertToXxx`：单对象转换（Account → UserInfo）
- `convertToXxxList`：列表转换（List<Account> → List<UserInfo>）
- `buildXxx`：构建新对象，包含简单字段映射之外的额外逻辑

**位置规范**：
- **简单转换**（1-10 个字段）：放在应用服务的私有方法中
- **复杂转换**（10+ 个字段，嵌套对象）：考虑提取到专门的 Converter 类
- **通用转换**（多个服务使用）：提取到 Common 模块

**实现规则**：
1. 转换方法只应映射字段，不包含业务逻辑
2. 一致使用 builder 模式或 setter
3. 适当处理 null 值
4. 转换方法应该是纯函数（无副作用）

### 规范4：异常处理的最佳实践

**异常处理规则**：
1. **业务异常**：直接抛出，不捕获
   - DuplicateUsernameException
   - InvalidPasswordException
   - AccountLockedException
   - AuthenticationException

2. **系统异常**：让它们传播到全局异常处理器
   - DatabaseException
   - NetworkException
   - UnexpectedRuntimeException

3. **主方法异常**：永远不要在主公共方法中使用 try/catch
   - 让异常自然传播
   - 全局异常处理器会记录日志并转换为 HTTP 响应

4. **何时使用 try/catch**：仅在特殊情况下需要返回结果而不是抛出异常
   - 示例：会话验证返回 `invalid` 结果而不是异常
   - 必须用注释记录原因

**好处**：
- 主方法保持干净
- 异常处理集中化
- 堆栈跟踪得以保留
- 更容易调试问题

### 规范5：审计日志的最佳实践

**日志规则**：
1. **审计日志**使用管道符分隔的结构化格式：
   ```
   [审计日志] 操作描述 | 字段1=值1 | 字段2=值2 | timestamp=时间戳
   ```

2. **日志方法**必须提取到私有方法：
   - 方法名模式：`log{操作}{状态}`（例如：logRegistrationSuccess、logLoginFailure）
   - 包含所有相关业务上下文（accountId、username、操作参数）
   - 始终包含 timestamp 字段

3. **需要审计日志的操作**：
   - 用户注册、登录、登出
   - 账号锁定、解锁
   - 权限变更
   - 敏感数据访问
   - 关键配置修改
   - 财务操作

4. **普通日志**使用逗号分隔的描述性格式：
   ```
   用户登录流程开始，用户名：john，IP：192.168.1.1
   ```

## 方法命名规范

### 验证方法

**规范**：
- `validate` 前缀：验证失败时抛出异常
- `check` 前缀：验证失败时返回 boolean 或 Optional

**规则**：
1. 验证方法名应描述正在验证的内容
2. 方法应只验证一件事（单一职责）
3. 抛出具有清晰消息的特定业务异常
4. 在抛出异常前在日志中包含相关上下文的警告

### 创建/构建方法

**规范**：
- `create` 前缀：创建领域对象（Account、Order、Session）
- `build` 前缀：构建 DTO（RegisterResult、LoginResult）

**规则**：
1. Create 方法返回领域实体
2. Build 方法返回 DTO
3. 方法名应指明正在创建/构建的内容
4. 可以包含额外逻辑如加密、默认值设置

### 转换方法

**规范**：
- `convertTo` 前缀：模型转换

**规则**：
1. 单对象：`convertToUserInfo(Account account)`
2. 列表：`convertToUserInfoList(List<Account> accounts)`
3. 应该是纯函数（无副作用）
4. 适当处理 null 值

### 日志方法

**规范**：
- `log` 前缀 + 业务动作

**规则**：
1. 方法名模式：`log{操作}{状态}`
   - logRegistrationSuccess
   - logLoginFailure
   - logAccountLocked
2. 安全相关操作使用结构化审计日志格式
3. 一般业务操作使用普通日志格式
4. 包含所有相关业务上下文

### 处理方法

**规范**：
- `handle` 前缀：处理特定业务场景

**规则**：
1. 方法名应描述正在处理的场景
2. 示例：handleLoginFailure、handleSessionExpired
3. 可以包含多个步骤（记录失败、锁定账号等）
4. 应封装处理该场景的所有逻辑

### 查找方法

**规范**：
- `find` 前缀：查询并返回领域对象

**规则**：
1. 简单查找：`findById`、`findByUsername`、`findByEmail`
2. 复杂查找：`findAccountByIdentifier`（先尝试用户名，然后邮箱）
3. 未找到时抛出特定异常（AccountNotFoundException）
4. 永远不返回 null，使用 Optional 或抛出异常

## 检查清单

在编写或审查 Application 层代码时，请使用此检查清单：

### 主方法检查

- [ ] 方法体包含 5-10 个清晰的步骤
- [ ] 每个步骤是一个方法调用，语义明确
- [ ] 主方法中没有 if/else 条件判断
- [ ] 主方法中没有 try/catch 异常处理
- [ ] 主方法中没有循环逻辑
- [ ] 主方法长度不超过 20 行
- [ ] 每个步骤都有编号注释（// 1. , // 2. , 等）

### 职责分离检查

- [ ] 数据验证逻辑封装在私有方法中
- [ ] 领域对象创建封装在私有方法中
- [ ] 模型转换逻辑封装在私有方法中
- [ ] 审计日志逻辑封装在私有方法中
- [ ] 业务规则在 Domain 层实现（不在 Application 层）

### 命名规范检查

- [ ] 验证方法使用 validate 或 check 前缀
- [ ] 创建方法使用 create 前缀
- [ ] 构建方法使用 build 前缀
- [ ] 转换方法使用 convertTo 前缀
- [ ] 日志方法使用 log 前缀
- [ ] 处理方法使用 handle 前缀
- [ ] 查找方法使用 find 前缀

### 异常处理检查

- [ ] 业务异常直接抛出（不捕获）
- [ ] 主方法中没有 try/catch（除了特殊记录的情况）
- [ ] 系统异常由全局异常处理器处理
- [ ] 异常消息清晰明确

### 代码质量检查

- [ ] 每个私有方法具有单一职责
- [ ] 方法名自文档化
- [ ] 私有方法之间没有重复代码
- [ ] 私有方法每个 5-20 行
- [ ] 正确使用 @Transactional 注解

## 常见错误

### 错误1：主方法包含大量 if/else

**问题**：主方法有 3+ 个 if/else 语句使其难以阅读

**解决方案**：将每个条件检查提取到具有清晰名称的私有方法中
- 错误：`if (lockInfo.isPresent()) { ... }`
- 正确：`checkAccountNotLocked(identifier);`

### 错误2：主方法包含详细的模型转换

**问题**：主方法有 10+ 行的 DTO 构建和字段映射

**解决方案**：提取到私有 `buildXxx` 或 `convertToXxx` 方法
- 错误：内联 10 行 `result.setXxx()` 调用
- 正确：`return buildRegisterResult(savedAccount);`

### 错误3：私有方法职责混乱

**问题**：单个方法既验证又创建/修改数据

**解决方案**：拆分成独立方法
- 错误：`validateAndCreateAccount()` - 做两件事
- 正确：`validateAccountUniqueness()` 和 `createAccount()` - 各做一件事

### 错误4：主方法中的 Try/Catch

**问题**：主方法被 try/catch 包裹，捕获后重新抛出业务异常

**解决方案**：移除 try/catch，让异常自然传播
- 错误：捕获业务异常只为了记录日志然后重新抛出
- 正确：没有 try/catch，异常传播到全局处理器

### 错误5：不明确的方法名

**问题**：方法名如 `process()`、`handle()`、`check()` 缺乏具体性

**解决方案**：使用描述正在处理/操作/检查内容的具体名称
- 错误：`processAccount()`、`handleRequest()`
- 正确：`validateAccountUniqueness()`、`handleLoginFailure()`

## 总结

Application 层的最佳实践核心是**保持主方法清晰简洁，将细节封装到私有方法中**。

**记住这三个原则**：
1. **5-10 步骤原则**：主方法包含 5-10 个清晰的编号步骤
2. **无条件判断原则**：主方法中避免 if/else、try/catch
3. **职责分离原则**：将验证、转换、日志等职责分离到不同方法

**成功的关键指标**：
- 主方法：15-20 行
- 每个步骤：单个方法调用
- 主方法中的 if/else：0
- 主方法中的 try/catch：0（除特殊情况）
- 私有辅助方法：每个 5-20 行

遵循这些原则，你的 Application 层代码将**清晰、可维护、易于测试**。
